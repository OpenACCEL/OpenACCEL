{
    "help_articles": {
        "Kees van Overveld": {
            "fName": "Kees van Overveld",
            "cat": "general",
            "help": "Creator of ACCEL, the predecessor of OpenACCEL.",
            "example": "",
            "details": "",
            "seeAlso": "kees, About OpenACCEL",
            "external": ""
        },
        "Changelog": {
            "fName": "Changelog",
            "cat": "general",
            "help": "<span class='versionspan'>v0.92</span><span class='versiondatespan'>(24-03-2015)</span><br /><ul><li>Added ability to upload scripts</li></ul><span class='versionspan'>v0.91</span><span class='versiondatespan'>(24-03-2015)</span><br /><ul><li>Added syntax highlighting to edit/run tab</li></ul><span class='versionspan'>v0.9</span><span class='versiondatespan'>(13-03-2015)</span><br /><ul><li>First public release</li></ul>",
            "example": "",
            "details": "",
            "seeAlso": "About OpenACCEL",
            "external": ""
        },
        "kees": {
            "fName": "kees",
            "cat": "special",
            "help": "Shows information about Kees van Overveld, the creator of ACCEL.",
            "example": "a=kees()",
            "details": "",
            "seeAlso": "Kees van Overveld",
            "external": ""
        },
        "About OpenACCEL": {
            "fName": "About OpenACCEL",
            "cat": "general",
            "help": "<b>Current maintainer: </b>&nbsp;Edward Brinkmann (e.k.brinkmann&lt;at&gt;student[dot]tue[dot]nl)<br/><br/><b>Original Development Team:</b><br/><ul><li>Edward Brinkmann</li><li>Philippe Denissen</li><li>Carl van Dueren den Hollander</li><li>Leo van Gansewinkel</li><li>Roel Jacobs</li><li>Kevin de Ridder</li><li>Jacco Snoeren</li><li>Roy Stoof</li><li>Loc Tran</li></ul><br/>",
            "example": "",
            "details": "OpenACCEL is the successor of ACCEL, which was created by Kees van Overveld. The initial development of OpenACCEL was commissioned by Kees and carried out by the above team of Computer Science Bachelor students at the Eindhoven University of Technology. Development began during the Software Engineering Projects (SEP) in Semester B Quartile 4 2014.",
            "seeAlso": "Changelog, Kees van Overveld",
            "external": ""
        },
        "auto-mapping": {
            "fName": "auto-mapping",
            "cat": "algebra",
            "help": "'Mapping' means: the application of a function to all elements of a set. For instance, mapping the function 'square' over the set {1,2,3,4} produces the set {1,4,9,16}. For functions with more than one argument, such as addition (add(x,y)=x+y), where either or both arguments could be taken from a set, there is a number of different ways to generalise this notion. For instance, we may want to regard the addition of two vectors, [1,2,3]+[10,20,30]=[11,22,33] as an example of mapping. At the same time, we may want to interpret the multiplication of a vector with a scalar, 3*[1,2,3]=[3,6,9] as an instance of mapping. To support both intuitions, +ACCELTM+ implements auto-mapping, to be explained below, for most of its built-in functions. ",
            "example": "[1,2,[3,4],'ba',[5,6]]+[10,20,[30,40],'nana',100]=[11,22,[33,44],'banana',[105,106]]. In particular notice that [3,4]+[30,40]=[33,44] whereas [5,6]+100=[ 105,106].",
            "details": "Auto-mapping in +ACCELTM+ uses the following strategy. <br><br>For a function, that is defined on scalar arguments, one or more of the arguments may be replaced by vectors. In that case, it is implicitly assumed that all scalar arguments are also vectors where all elements are equal. So the scalar argument '12' is replaced by the vector '[12,12,12,12...]'. All argument-vectors will be of the same length, namely the length of the shortest vector that appears as an argument. So [1,2,3,4,5]+100=[101,102,103,104,105], but [1,2,3,4,5]+[100]=[101]. Any argument vectors that are longer than this length are truncated, that is: their trailing elements are ignored. <br><br>Auto-mapping is applied recursively. That is, if an element of a vector is again a vector, auto-mapping expands the corresponding scalar elements in the other argument vectors also to become vectors. So, for instance, [1,[2,3]]+[[10,20],30]=[[11,21],[32,33]].<br><br> Auto-mapping applies to both nominal indices (=keys, or strings, as index) and ordinal indices (=integer numbers as index). For ordinal indices the rule applies that the shortest occurring range of indices determines the scope of the mapping (for instance [1,2,3,4]+[1,2,3]=[2,4,6]). For nominal indices, the rule applies that only those elements with common keys are used for auto-mapping (for instance ['a':1,'b':2,'c':3,'d':4,'e':5]+['a':1,'b':2,'c':3,'x':4,'y':5]=['a':2,'b':4,'c':6]",
            "seeAlso": "scalar,vector,quantified expression,quantor",
            "external": ""
        },
        "add": {
            "fName": "add",
            "cat": "algebra",
            "nArgs": 2,
            "help": "add(x,y)=x + y.",
            "autoMapping": "Supports auto-mapping.",
            "example": "5+4=9<br>'aa'+'bb'='aabb'<br>7+'up'='7up'<br>[3,4,'xxx']+[6,'john','yyy']=[9,'4john','xxxyyy']",
            "abbreviation": "add(x,y)= x+y",
            "details": "The add function cannot be used to add all elements in a vector together. The function vNormFlat can be used for that purpose.",
            "seeAlso": "subtract,multiply,divide,vNormFlat",
            "external": ""
        },
        "subtract": {
            "fName": "subtract",
            "nArgs": 2,
            "cat": "algebra",
            "help": "subtract(x,y)=x - y.",
            "autoMapping": "Supports auto-mapping.",
            "example": "5-4=1<br>4-5= -1<br>'banana'-'nana'=NaN - in other words, no attempts are done to give subtraction a meaningful behaviour for strings.",
            "abbreviation": "subtract(x,y)= x-y",
            "details": "",
            "seeAlso": "add,multiply,divide",
            "external": ""
        },
        "multiply": {
            "fName": "multiply",
            "nArgs": 2,
            "cat": "algebra",
            "help": "multiply(x,y)=x * y.",
            "autoMapping": "Supports auto-mapping.",
            "example": "5*4=20<br>-5*(-1/5)=1<br>'banana'*4=NaN - in other words, no attempts are done to give multiplication a meaningful behaviour for strings.",
            "abbreviation": "multiply(x,y)= x*y",
            "details": "",
            "seeAlso": "add,subtract,divide",
            "external": ""
        },
        "divide": {
            "fName": "divide",
            "nArgs": 2,
            "cat": "algebra",
            "help": "divide(x,y)=x / y for y different from 0.",
            "autoMapping": "Supports auto-mapping.",
            "example": "5/4=1.2<br>12/0=NaN<br>'dadadada'/'da'=NaN - in other words, no attempts are done to give division a meaningful behaviour for strings.",
            "abbreviation": "divide(x,y)= x/y",
            "details": "",
            "seeAlso": "add,subtract,multiply",
            "external": ""
        },
        "modulo": {
            "fName": "modulo",
            "nArgs": 2,
            "cat": "algebra",
            "help": "modulo(x,y)= remainder by dividing x through y for y different from 0.",
            "autoMapping": "Supports auto-mapping.",
            "example": "5%4=1<br>-101%10=-1 -- and not 1 as one would expect from mathematics. On the other hand, 101 %(-10) = 1.<br>'dadadadaba'%'da'=NaN - in other words, no attempts are done to give modulo a meaningful behaviour for strings.",
            "abbreviation": "modulo(x,y)= x % y",
            "seeAlso": "divide",
            "details": "Modulo does give the expected results for non-integer positive arguments. For instance, 101.5 % 10 = 1.5. ",
            "external": "+ACCELTM+ uses the javascript definitions for quantities and algebraic operations as its reference. A discussion on the odd behaviour of javascript's modulo function can be found here: <a href='http://javascript.about.com/od/problemsolving/a/modulobug.htm'>http://javascript.about.com/od/problemsolving/a/modulobug.htm</a>"
        },
        "abs": {
            "fName": "abs",
            "nArgs": 1,
            "cat": "algebra",
            "help": "abs(x)= x if x &gt  0, otherwise -x.",
            "autoMapping": "Supports auto-mapping.",
            "example": "abs(-5)=5",
            "abbreviation": "No abbreviation.",
            "seeAlso": "vNorm",
            "details": "",
            "external": ""
        },
        "min": {
            "fName": "min",
            "nArgs": 2,
            "cat": "algebra",
            "help": "min(x,y)= the smaller of x and y",
            "autoMapping": "Supports auto-mapping.",
            "example": "min(5,-5)=-5<br>min('aaa','zzz')='aaa'",
            "abbreviation": "No abbreviation.",
            "seeAlso": "subtract",
            "details": "For the lexicographic ordering, the ascii-values of characters are used.",
            "external": "The acii values for characters can be found here: >a href='http://www.asciitable.com/',http://www.asciitable.com/</a>"
        },
        "max": {
            "fName": "max",
            "nArgs": 2,
            "cat": "algebra",
            "help": "max(x,y)= the larger of x and y",
            "autoMapping": "Supports auto-mapping.",
            "example": "max(5,-5)=5<br>max('aaa','zzz')='zzz'",
            "abbreviation": "No abbreviation.",
            "seeAlso": "subtract",
            "details": "For the lexicographic ordering, the ascii-values of characters are used.",
            "external": "The acii values for characters can be found here: >a href='http://www.asciitable.com/',http://www.asciitable.com/</a>"
        },
        "round": {
            "fName": "round",
            "nArgs": 1,
            "cat": "algebra",
            "help": "round(x)= the integer value nearest to x",
            "autoMapping": "Supports auto-mapping.",
            "example": "round(-2.4)=-2<br>round(-2.5)=-2<br>round(-2.6)=-3<br>round(2.4)=2<br>round(2.5)=3<br>round(2.6)=3",
            "abbreviation": "No abbreviation.",
            "seeAlso": "ceil,floor",
            "details": "The convention is used that integer+0.5 is rounded up, both for positive and negative arguments.",
            "external": ""
        },
        "ceil": {
            "fName": "ceil",
            "nArgs": 1,
            "cat": "algebra",
            "help": "ceil(x)=the smallest integer not larger than x",
            "autoMapping": "Supports auto-mapping.",
            "example": "ceil(3.5)=4<br>ceil(4)=4<br>ceil(-3.5)=-3<br>ceil(-4)=-4",
            "abbreviation": "No abbreviation.",
            "seeAlso": "floor,round",
            "details": "",
            "external": ""
        },
        "floor": {
            "fName": "floor",
            "nArgs": 1,
            "cat": "algebra",
            "help": "floor(x)=the largest integer not smaller than x",
            "autoMapping": "Supports auto-mapping.",
            "example": "floor(3.5)=3<br>floor(4)=4<br>floor(-3.5)=-4<br>floor(-4)=-4",
            "abbreviation": "No abbreviation.",
            "seeAlso": "ceil,round",
            "details": "",
            "external": ""
        },
        "sqrt": {
            "fName": "sqrt",
            "nArgs": 1,
            "cat": "algebra",
            "help": "sqrt(x)=the number y such that y * y = x, for non-negative x.",
            "autoMapping": "Supports auto-mapping.",
            "example": "sqrt(9)=3<br>sqrt(-9)=NaN",
            "abbreviation": "No abbreviation.",
            "seeAlso": "pow",
            "details": "",
            "external": ""
        },
        "uniminus": {
            "fName": "uniminus",
            "nArgs": 1,
            "cat": "algebra",
            "help": "uniminus(x)= -x",
            "autoMapping": "Supports auto-mapping.",
            "example": "uniminus(3)= -3<br>uniminus(-3)=3<br>uniminus(0)=0",
            "abbreviation": "No abbreviation.",
            "seeAlso": "subtract,min",
            "details": "",
            "external": ""
        },
        "iMake": {
            "fName": "iMake",
            "nArgs": 3,
            "cat": "image",
            "help": "iMake(x,nrRows,nrCols) creates a vector of nRows vectors, each containnig nCols copies of x. Indices are integers starting with 0. If nRows or nCols &lt 0, an empty vector is returned.",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "No abbreviation.",
            "example": "iMake(3,2,2)=[[3,3],[3,3]]<br>vMake('bla',1,1)=[['bla']]",
            "details": "Typically, iMake is +ACCELTM+'s simplest way to construct images.",
            "seeAlso": "iSpike,iGaussian,vMake",
            "external": "In linear algebra, vectors are usually given in some frame. This frame is defnied by a basis. The basis consists of vectors. Ever wondered where these basis vectors come from?"
        },
        "iGaussian": {
            "fName": "iGaussian",
            "nArgs": 4,
            "cat": "image",
            "help": "iGaussian(n1,n2,s1,s2) creates a vector of n1 vectors each of n2 scalar elements; indices are integers starting with 0. Element [i][j] has value P*exp(-(i-n1/2)*(i-n1/2)/(2*s1*s1)-(j-n2/2)*(j-n2/2)/(2*s2*s2)), where i ranges from 0 to n1-1, j from 0 to n2-1, and where P is such that the sum over all elements is one.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "Notice 1:The third and fourth arguments plays the role of sigma in the standard definition of the Gaussian. These don't have to be integer. The Gaussian has an infinite support; parameters n1 and n2 are necessarily is finite. Therefore, the resulting Gaussian will always be a truncated version, even if the ratio between n and s is very large. The normalisation nevertheless ensures that the (truncated) Gaussian can serve e.g. as a stable low pass filter.<br>Notice 2:For even n, the resulting approximation has no single extreme apex. For odd n, there is a single extreme apex.",
            "seeAlso": "vConvolve,vGaussian,iConvolve",
            "external": "See <a href='http://en.wikipedia.org/wiki/Gaussian_function'>http://en.wikipedia.org/wiki/Gaussian_function</a>",
            "abbreviation": "No abbreviation",
            "example": ""
        },
        "iSpike": {
            "fName": "iSpike",
            "nArgs": 4,
            "cat": "image",
            "help": "iSpike(x1,x2,y1,y2) creates a vector of y1 vectors each of y2 elements. Indices areintegers starting with 0. The elements are all zero, except the element at location y1==x1, y2==x2, assuming both x &lt y, which is set to 1.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "iSpike(0,0,3,3)=[[1,0,0],[0,0,0],[0,0,0]]",
            "seeAlso": "iMake,iConvolve,iGaussian,vSpike",
            "abbreviation": "No abbreviation",
            "details": "Often, a smooth 'bump' is required, e.g. to model some perturbation. A simple way to achieve this is to use a convolution of a spike with a Guassian: the location of the spike determines the centre position of the bump, and the Gaussian determined its width. For instance: bump=amplitude*iConvolve(iSpike(n*random(),n*random(),n,n),iGaussian(gWidth,gWidth,gSharp,gSharp),5,0)",
            "external": "There is a conceptual similarity between a spike and a Dirac delta function: <a href='http://en.wikipedia.org/wiki/Dirac_delta_function'>http://en.wikipedia.org/wiki/Dirac_delta_function</a>."
        },
        "iConvolve": {
            "fName": "iConvolve",
            "nArgs": 5,
            "cat": "image",
            "autoMapping": "Does not support auto-mapping.",
            "help": "iConvolve(x,y,n1,n2,m) calculates the convolution of x with y, shifted over [n1,n2]. That is: return[i1][i2]:=sum over j1 of sum over j2 of x[i1-n1+j1][i2-n2+j2]*y[j1][j2]. The return image has the same dimensions as x. If m==0 the convolution is cyclic, if m==1 the convolution is zero-padded, that is: it is pretended that the vector x is extended with zeroes on both ends. If m==2 the convolution is padded with the border elements of x,that is: it is pretended that the vector x is extended with all the same elements on the border.",
            "abbreviation": "No abbreviation.",
            "details": "The convolution can be used to implement e.g. a differentiation operator. Let v be an image, then iConvolve(v,kernel,shift1,shift2,0) is a discrete approximation of the Laplacian of v with respect to its index. The kernel could e.g. look like [[0,-1,0],[-1,4,-1],[0,-1,0]] and the shift then should be [1,1] (indeed, the central value for the kernel is assumed for index [1][1]). This small kernel is rather sensitive for small details. A broader kernel with correspondingly larger shift 3 is less sensitive for small details and therefore gives a smoother result.<br><br>Notice: convolve applies addition to indices. Therefore indices must be integers; non-integer indices are ignored.",
            "example": "wArr=w*xArr{1}-(wArr{2}+iConvolve(wArr{1},kernel,1,1,0)), with kernel=[[0,-1,0],[-1,4,-1],[0,-1,0]]/20 implements a very simple solver for a 2-dimensional wave equation with an approximation for a second time derivative and a second 'spatial' derivative.",
            "seeAlso": "iSpike,iGaussian,vConcolvolve,iMedian",
            "external": "See <a href='http://en.wikipedia.org/wiki/Convolution'>http://en.wikipedia.org/wiki/Convolution</a>"
        },
        "iMedian": {
            "fName": "iMedian",
            "nArgs": 3,
            "cat": "image",
            "autoMapping": "Does not support auto-mapping.",
            "help": "iMedian(x,n,m) calculates the median of x over a footprint with dimension 2n+1. Here, n is at least 1. If n==1, then the median over a square of 3x3 samples is calculated. Parameter m determines if the median should be wrapped around (m==0), zero padded (m==1) or computed with copies of the border elements (m==2)",
            "abbreviation": "No abbreviation.",
            "details": "The median can e.g. be used to implement game of life or other cellular automatons.",
            "example": "wArr=iMedian(wArr{1}+noise) is a simple non-linear reaction-diffusion model.",
            "seeAlso": "iSpike,iGaussian,vConcolvolve,iConvolve",
            "external": "See <a href='http://en.wikipedia.org/wiki/Median_filter'>http://en.wikipedia.org/wiki/Median_filter</a>"
        },
        "image funcions": {
            "fName": "image funcions",
            "cat": "image",
            "help": "+ACCELTM+'s approach to 2D data is as vectors of vectors, where all indices are integers (offset 0). An image quantity is therefore a vector quantity; all vectors are assumed to have equal length. The functions that produce images (such iMake,iSpike, iGaussian and iConvolve) ensure that an image is a full rectangular vector of vectors. Image functions take arbitrary vectors of vectors, but there is no runtime check to verify if all rows are equally long. In case unequal lengths occur, results are unpredictable. Auto mapping applies to image quantities. Image quantities quantities are denoted by square brackets, and the elements are again expressions in square brackets: [1,2,3]  is a vector of three scalars.",
            "autoMapping": "The behavior of many operators depends on whether the arguments are scalars or vectors. For instance, in 3+5, the '+' operator takes two scalar arguments, and produces the scalar result '8'. In [1,1]+[5,6], arguments are vectors, and the result is the vector [6,7]. For images, [[1,1],[2,2]]+[[1,2],[1,2]]=[[1,2],[3,4]]",
            "details": "Vectors realise the intuition of <span class=\"accelEmph\">2D grouping</span> for the special case where all indices are integers and indices of row vectors all have the same range. (i.e., all row vectors are equally long)",
            "seeAlso": "auto-mapping,scalar,data type,hierarchy,indexing,nominal,ordinal,image",
            "abbreviation": "Every quantity in +ACCELTM+ can be either scalar or vector, and therefore also image."
        },
        "lessThanEqual": {
            "fName": "lessThanEqual",
            "nArgs": 2,
            "cat": "logic",
            "help": "lessThanEqual(x,y)= true iff x is less than or equal to y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3 &lt =4)==true<br>(3 &lt =[2,3,4,5])=[false,true,true,true]",
            "abbreviation": "lessThanEqual(x,y)=(x &lt =y)",
            "seeAlso": "greaterThanEqual,lessThan,greaterThan,equal,notEqual,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "lessThan": {
            "fName": "lessThan",
            "nArgs": 2,
            "cat": "logic",
            "help": "lessThan(x,y)= true iff x is less than y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3 &lt 4)==true<br>(3 &lt [2,3,4,5])=[false,false,true,true]",
            "abbreviation": "lessThan(x,y)=(x &lt y)",
            "seeAlso": "greaterThanEqual,lessThanEqual,greaterThan,equal,notEqual,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "greaterThanEqual": {
            "fName": "greaterThanEqual",
            "nArgs": 2,
            "cat": "logic",
            "help": "greaterThanEqual(x,y)= true iff x is greater than or equal to y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3 &gt =4)==false<br>(3 &gt =[2,3,4,5])=[true,true,false,false]",
            "abbreviation": "greaterThanEqual(x,y)=(x &gt =y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThan,equal,notEqual,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "greaterThan": {
            "fName": "greaterThan",
            "nArgs": 2,
            "cat": "logic",
            "help": "greaterThan(x,y)= true iff x is greater than y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3 &gt 4)==false<br>(3 &gt [2,3,4,5])=[true,false,false,false]",
            "abbreviation": "greaterThan(x,y)=(x &gt y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,equal,notEqual,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "equal": {
            "fName": "equal",
            "nArgs": 2,
            "cat": "logic",
            "help": "equal(x,y)= true iff x is equal to y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3==4)==false<br>(3==[2,3,4,5])=[false,true,false,false]",
            "abbreviation": "equal(x,y)=(x==y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,notEqual,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "notEqual": {
            "fName": "notEqual",
            "nArgs": 2,
            "cat": "logic",
            "help": "notEqual(x,y)= true iff x differs from y",
            "autoMapping": "Supports auto-mapping.",
            "example": "(3!=4)==true<br>(3!=[2,3,4,5])=[true,false,true,true]",
            "abbreviation": "notEqual(x,y)=(x!=y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,if,not,and,or,imply",
            "details": "",
            "external": ""
        },
        "if": {
            "fName": "if",
            "nArgs": 3,
            "cat": "logic",
            "help": "if(x,y,z) is y if x == true, else it is z",
            "autoMapping": "Supports auto-mapping, as follows: if x is a scalar, y and z can be arbitrary types - including vectors of different lengths. If x is a vector, y and z must either be vectors of the same length as x, or scalar. For instance, if([true,true,false],3,[4,5,6]) returns the array [3,3,6], and not as one might expect, the array [3,3,[4,5,6]].",
            "example": "if(a>b,a,b) is an implementation of the max(a,b) function",
            "abbreviation": "No abbreviation",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,notEqual,not,and,or,cond",
            "details": "The +ACCELTM+ implementation of the if-statement is a function. That means that all three arguments of the if()-function first must be evaluation before the if()-function returns a result. It is possible that one of the two alternatives (2nd or 3rd argument) generates a run-time exception, such as a type error (vector of wrong size, or a vector in stead of a scalar). If this alternative is not to be returned as the result of the if()-function, such an exception does not hamper the evaluation of the script.<br><br>There is a (typically small) penalty issue, however: it is possible that one alternative takes a large amount of computation resources. In case this alternative is not to be chosen, we may (in rare cases) waste a significant amount af processor capacity. An alternative implementation uses a so-called <span class=\"accelEmph\">conditional evaluation</span>: only that alternative is evaluated that is actually going to be returned. This is achieved by the language construct 'cond(condition,alternative1, alternative 2)'. Notice that the 'cond'-construction does not support auto-mapping, though.",
            "external": "For a more extensive discussion of conditional statements, see <a href='http://en.wikipedia.org/wiki/%3F:'>http://en.wikipedia.org/wiki/%3F:</a>."
        },
        "cond": {
            "fName": "cond",
            "nArgs": 3,
            "cat": "logic",
            "help": "cond(x,y,z) is y if x == true, else it is z",
            "autoMapping": "Does not support auto-mapping: if x is a vector, this is interpreted as 'false' irrespective of the values of its elements. The two expressions y and z, however, can both be scalar or vector. If auto-mapping is required, use the function if(condition,alternative1, alternative2) instead.",
            "example": "cond(a>b,a,b) is an implementation of the max(a,b) function",
            "abbreviation": "No abbreviation",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,notEqual,not,and,or,if",
            "details": "The +ACCELTM+ implementation of the cond-statement is not a function. That means that, of the three arguments of the cond()-construction, only the first one (the so-called guard) is always evaluated. Of the two expressions, y and z, only one is evaluated. If the not-evaluated alternative would have generated a run-time exception, such as a type error (vector of wrong size, or a vector in stead of a scalar), this exception now will not take place.<br><br>There is a (typically small) performace issue, where cond() is faster than if(). Indeed, suppose one alternative takes a large amount of computation resources. In case this alternative is not to be chosen, the if() function would waste a significant amount af processor capacity. ",
            "external": "For a more extensive discussion of conditional statements, see <a href='http://en.wikipedia.org/wiki/%3F:'>http://en.wikipedia.org/wiki/%3F:</a>."
        },
        "not": {
            "fName": "not",
            "nArgs": 1,
            "cat": "logic",
            "help": "not(x)= true iff x is false and vice versa",
            "autoMapping": "Supports auto-mapping.",
            "example": "(!(3!=4))==false<br>(!(3!=[2,3,4,5]))=[false,true,false,false]",
            "abbreviation": "not(x)=(!x)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,if,notEqual,and,or,imply",
            "details": "",
            "external": ""
        },
        "and": {
            "fName": "and",
            "nArgs": 2,
            "cat": "logic",
            "help": "and(x,y)= true iff both x and y are true",
            "autoMapping": "Supports auto-mapping.",
            "example": "a && true = a <br> a && false = false",
            "abbreviation": "and(x,y)=(x && y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,if,notEqual,not,or,imply",
            "details": "",
            "external": ""
        },
        "or": {
            "fName": "or",
            "nArgs": 2,
            "cat": "logic",
            "help": "or(x,y)= true iff  x or y or both are true",
            "autoMapping": "Supports auto-mapping.",
            "example": "a || true = true <br> a || false = a",
            "abbreviation": "or(x,y)=(x || y)",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,if,notEqual,not,and,imply",
            "details": "",
            "external": ""
        },
        "imply": {
            "fName": "imply",
            "nArgs": 2,
            "cat": "logic",
            "help": "imply(x,y)= true iff  y is true or x is false",
            "autoMapping": "Supports auto-mapping.",
            "example": "imply(false,a)=true, imply(a,true)=true",
            "abbreviation": "no abbreviation",
            "seeAlso": "lessThanEqual,lessThan,greaterThanEqual,greaterThan,equal,notEqual,if,not,and,or",
            "details": "",
            "external": ""
        },
        "plot": {
            "fName": "plot",
            "nArgs": 1,
            "cat": "special",
            "help": "plot( ) is an obsolete instruction to +DESCARTESTM+-graph drawing sub-system. As of May 2014, the function descartes( ) should be used instead.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "'pl=descartes([[locations:[data:[[y:100*random()]],x:[mode:'intp'],y:[mode:'shift']]]])'<br><br>is the equivalent, using descartes() for what formerly was written as<br><br>'pl=plot([[[plotType:'bubble',nrPoints:20,x:[mode:'intp'],y:[mode:'shift',ref:1],radius:10],[100*random()]]])'.",
            "details": "",
            "seeAlso": "Descartes",
            "external": "",
            "abbreviation": ""
        },
        "descartes": {
            "fName": "descartes",
            "nArgs": 1,
            "cat": "special",
            "help": "descartes(x)=instruction to +DESCARTESTM+-graph drawing sub-system.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "'pl=descartes([[locations:[data:[[y:100*random()]],x:[mode:'intp'],y:[mode:'shift']]]])' produces a horizontally moving collection of dots with random y-coordinates.",
            "details": "Consider the example below:<br><br> 'pl=descartes([[locations:[data:[[y:100*random()]],x:[mode:'intp'],y:[mode:'shift']]]])', <br><br>which produces a horizontally moving collection of dots with random y-coordinates.<br><br>To achieve such visual representations, +DESCARTESTM+ makes use of an extensive set of concepts, each defined as an array of properties, where every property comes with a plausible default. The values of properties in some cases can be concepts (arrays) in themselves, and recursively. This is even true at the top level of the concept hierarchy, where the type of graph to be plotted is defined. This type of graph can be one of the following: <em>geometry</em>, <em>image</em> or <em>contour</em>. The default is <em>geometry</em>, so the property <em>geometry</em> may be omitted, and the entire expression <br><br>[locations:[data:[[y:100*random()]],x:[mode:'intp'],y:[mode:'shift']]]<br><br> is the value of the property <em>geometry</em>. <br><br>The properties of <em>geometry</em> are, among other things, <em>locations</em>. Others are <em>edges</em> and <em>faces</em>, but we can also provide a camera, all sorts of lights for 3-D configuration, and a grid to facilitate more convenient quantitative inspection of the graph. <br><br>In this example, <em>locations</em> is the only property provided. Its value is <br><br>[data:[[y:100*random()]],x:[mode:'intp'],y:[mode:'shift']].<br><br> This value is an aggregation, i.e. a compound concept, with properties of its own, namely <em>data</em>, <em>x</em> and <em>y</em>. Indeed, values of property <em>locations</em> have properties such as <em>x</em> and <em>y</em>. <br><br>We provide a collection of x- and y-coordinates, in the property called <em>data</em>.  The value of <em>data</em> is an array where every element defines one location with 2 (x,y) or 3 (x,y,z) coordinates, colors, various visual icons, text tags and more. In this case, the array <em>data</em> contains merely a single element, namely<br><br>[y:100*random()].<br><br> We specify a single location, and for this sinlge location we specify merely a single property, namely the y-coordinate as a random number between 0 and 100.<br><br>We give more information, however, on the locations to be plotted. We do this by saying someting about the x and y-coordinates of locations in general. That is, we make statements about x and y-coordinates that hold for any location. This is done by means of the <em>x</em> and <y>y</em> properties of concept <em>locations</em>, defined as <br><br>x:[mode:'intp']<br><br> and <br><br>y:[mode:'shift'],<br><br> respectively. These statements instruct +DESCARTESTM+ what to do with the information found in the <em>data</em> array. This can be to provide values for additional properties: indeed, <em>x</em> is not given in the <em>data</em>-array, and 'x:[mode:'intp']' is an instruction to provide x-values (for all possible locations) by means of interpolation between plausible default values. Similarly, it can provide instructions of how to process values, perhaps taken from the <em>data</em> array: 'y:[mode:'shift']' means that a sequence of y-values is obtained from the y-value from a single location given in <em>data</em> by repeatedly shifting the value(s) from the previous rendition to next locations. This is used to mimick the effect of drawing on a rolling strip of paper as in EEG-machines or earthquake registration equipment. <br><br>The full set of all concepts and properties in the +DESCARTESTM+ can be browsed by means of the help-pages; suitable starting points for getting familiar with the +DESCARTESTM+ system are the keywords <em>geometry</em>, <em>image</em>, <em>contour</em> or any of the other property names. Also, the collection of demo scripts contain numerous examples of using +DESCARTESTM+.",
            "seeAlso": "descartes,plot,graph,geometry,image,contour,properties,grid",
            "external": "",
            "abbreviation": ""
        },
        "debug": {
            "fName": "debug",
            "nArgs": 2,
            "cat": "special",
            "help": "debug(c,v) prints the values in vector v to the debug-output, preceeded by the string c. The function returns the value v['return']. Since v is a vector, several values at once can be debugged. The debug output (if present) is shown in a separate popup window. The window is automatically minimized at every mouseclick, but it can be re-openened from the task bar at any time for further perusing.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "myFunc(x)=debug('calculates factorial of x', ['arg':x, 'return':cond(x<=1,1,myFunc(x-1)*x)]) is a convenient way to debug user-defined functions",
            "details": "The second argument is a vector; all values in the vector are echood to the debug output; only the  element named 'return' is returned to the caller. An element 'return': (some value) is mandatory.",
            "external": "",
            "seeAlso": "",
            "abbreviation": ""
        },
        "do": {
            "fName": "do",
            "nArgs": 2,
            "cat": "special",
            "help": "do('script',[par1:val1, par:val2, ... parN:valN]) executes the Javascript fragment in string 'script',  where _par1 is substituted by the serialized version of val1, _par2 is substituted by the serialized version of val2, etc.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=do('var k=_arr;return k.sort()',['arr':[s1,s2,s3,s4]])<br>s1=slider(1.0,0,10)<br>s2=slider(1.0,0,10)<br>s3=slider(1.0,0,10)<br>s4=slider(1.0,0,10)<br> returns the values of the four sliders, s1, s2 s3, s4 in sorted order.",
            "details": "ACCEL uses the functional programming paradigm throughout. Some tasks, however, are awkward or perhaps impossible to code using functions only. Therefore it is possible to execute an algorithm given in Javascript, where ACCEL-quantities can be passed as arguments. These ACCEL quantities get their current values serialized (that is, converted to a string) and substituted in the slots in the script named '_par' where 'par' is the name of one of the 0 or more proporties in the 2nd argument vector.",
            "external": "",
            "seeAlso": "",
            "abbreviation": ""
        },
        "ramp": {
            "fName": "ramp",
            "nArgs": 5,
            "cat": "special",
            "help": "ramp(x,x1,y1,x2,y2)=y1 if x&lt=x1; y2 if x&gt=x2; (x-x1)*(y2-y1)/(x2-x1) if x1&ltx&ltx2. If(x1==x2), rmp(x,x1,y1,x2,y2)=(y1+y2)/2.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "ramp(0.5,0,0,1,1)=0.5",
            "details": "Sometimes, functional dependencies are known to be monotonic (increasing or decreasing), and to have saturation (not exceeding certain values). If the precise behaviour of such functions is not known, it is sometimes reasonable to assume them to be piecewise linear. The ramp function is the simples linear interpolation function that features saturation. <br><br>Notice: the function vVecRamp implements a generalised version of the ramp-function that takes multiple linearly interpolated segments.",
            "external": "",
            "seeAlso": "vVecRamp",
            "abbreviation": ""
        },
        "getUrl": {
            "fName": "getUrl",
            "nArgs": 1,
            "cat": "special",
            "help": "getUrl('www.mySite.com?par1=3&par2=5') does a get-call to the site 'mySite' with parameters par1 and par2, taking values 3 and 5, and returns the obtained data.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "http://keesvanoverveld.com/mapKey/keyMapDBI.php?task=getTerm&key=myKey",
            "details": "In getUrl('http://keesvanoverveld.com/mapKey/keyMapDBI.php?task=getTerm&key=myKey'), a value is sought that is associated to a key 'myKey'. The connection between this key and an arbitrary value 'myTerm' is established, for instance, by a call http://keesvanoverveld.com/mapKey/keyMapDBI.php?task=setTerm&key=myKey&term=myTerm. If the term 'myTerm' should be understood by ACCEL, it should be an ACCEL quantity.<br><br>Any Internet call, resulting from a call to getUrl() is postfixed by ACCEL by a dummy parameter with a randomized value. This ensures that values are not taken from the browser cache.<br><br>If the function getURL() occurs in an ACCEL script, it may easily be excuted hundred times or more per second. This would cause a large amount of redundant Internet traffic. Therefore, a call to getURL() is only passed to a single server if no POST_ nor GET-call to the same server was passed more recently than 1000 milliseconds. This means that rapid (faster then, say, once every few seconds) server-side updates may be missed. Data to be retrieved from a server therefore should be state-related, not state-transition-related data.<br><br>The URL http://keesvanoverveld.com/mapKey/keyMapDBI.php is made available as a courtesy to ACCEL users to enable multi-user applications, where multiple users can give asynchronous input to a running ACCEL script. Using getUrl, connections between various ACCEL instances can be established. Also, communication between ACCEL-instances may be point-to-point, broadcast or multi-cast. An example is the implementation of a (more or less) real-time multi-player game. <br><br>Any website that produces data can be queried using getURL(); an arbitrary website, however, will produce html-data that is generally meaningless to an ACCEL script. It may even crash a running ACCEL instance. The ACCEL-programmer is therefore responsible for dealing with the data format.<br><br>Notice that using the function getUrl() we can also export data to a server. So using only getUrl()-functions, we can establish a communication network involving several instances of ACCEL communicating to each other and other servers, either in point-to-point mode or by using broadcast or multicast communication. Unlike CSP-type communication, however, the channels are not buffered and information can get out-of-order; due to the sampling-mode (=only communicate when 1000 milliseconds before no communication was done to the same server), data may even get lost. For this reason, it is not recommended to have more than a single call to getUrl() to the same host in a script. If both input and output to external resources should be provided, consider using the functions getChan and putChan instead.",
            "external": "",
            "seeAlso": "time,vector,getChan,putChan",
            "abbreviation": ""
        },
        "getChan": {
            "fName": "getChan",
            "nArgs": 1,
            "cat": "special",
            "help": "getChan('myChannelName') does a get-call to a channel server. The channel server associates data to channel names. The call getChan('myChannelName') asks for the most recent value associated to the channel with name 'myChannelName'.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=getChan('myChannelName')",
            "details": "The functions getChan() and putChan() are wrappers around the more generic function getUrl(). The latter function, however, should not be called multiple times (with different arguments) to the same host in one script. One should use channels instead. Multiple channels don't interfere with each other. <br><br>If the return value of getChan() should be understood by ACCEL, it should be an ACCEL quantity; aggregated quantities are allowed. <br><br>To limit bandwidth, a call to getChan() is only executed if a call with the same argument was not performed more recently than 1000 milliseconds ago. This means that rapid (faster then, say, once every few seconds) server-side updates may be missed. Data to be retrieved from this channel therefore should be state-related, not state-transition-related data.<br><br>Combining getChan and putChan, connections between various ACCEL instances can be established. Also, communication between ACCEL-instances may be point-to-point, broadcast or multi-cast. An example is the implementation of a (more or less) real-time multi-player game.<br><br>Notice that the argument of getChan() (the channel name) is just a string. That means that the possibility exists that, at the same time, another instance of ACCEL communicates over the same channel, thereby unintentionally altering communicated data. It is therefore recommended to use channel names that are unlikely to occur, e.g. prefix them by some random characters.",
            "external": "",
            "seeAlso": "time,vector,getUrl,putChan",
            "abbreviation": ""
        },
        "putChan": {
            "fName": "putChan",
            "nArgs": 2,
            "cat": "special",
            "help": "putChan('myChannelName',myValue) does a put-call to a channel server. The channel server associates data to channel names. The call putChan('myChannelName',myValue) associates the value myValue to the channel named 'myChannelName'.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=putChan('myChannelName',[1,2,3,4])",
            "details": "The functions getChan() and putChan() are wrappers around the more generic function getUrl(). The latter function, however, should not be called multiple times (with different arguments) to the same host in one script. One should use channels instead. Multiple channels don't interfere with each other. <br><br>If the second argument of getChan() should be understood by ACCEL, it should be an ACCEL quantity. The return value of putChan() equals the second argument. <br><br>To limit bandwidth, a call to getChan() is only executed if a call with the same argument was not performed more recently than 1000 milliseconds ago. This means that rapid (faster then, say, once every few seconds) server-side updates may be missed. Data to be sent via this channel therefore should be state-related, not state-transition-related data.<br><br>Combining getChan and putChan, connections between various ACCEL instances can be established. Also, communication between ACCEL-instances may be point-to-point, broadcast or multi-cast. An example is the implementation of a (more or less) real-time multi-player game.<br><br>Notice that the argument of getChan() (the channel name) is just a string. That means that the possibility exists that, at the same time, another instance of ACCEL communicates over the same channel, thereby unintentionally altering communicated data. It is therefore recommended to use channel names that are unlikely to occur, e.g. prefix them by some random characters.<br><br>putChan() uses the http get-mode. That means that data is send as part of the URL. This imposes a limit to the amount of data that can be communicated by a call to putChan(). This limit is be browser dependent. The de facto limit for a URL is taken to be 2000 characters. This means that the serialized version of the data should not be more than, say, 1800 characters. Data is serialized according to the ACCEL syntax for compound quantities.",
            "external": "",
            "seeAlso": "time,vector,getChan,getUrl",
            "abbreviation": ""
        },
        "getTime": {
            "fName": "getTime",
            "nArgs": 0,
            "cat": "special",
            "help": "getTime() returns the number of milliseconds since january 1st, 1970",
            "autoMapping": "Does not support auto-mapping.",
            "example": "time()= (a very large number)",
            "details": "If performance is an issue, the function time() can be usefull to assess how long parts of a calculation take, how many frames per second are generated, et cetera.",
            "seeAlso": "clock,performance,real time",
            "abbreviation": ""
        },
        "slider": {
            "fName": "slider",
            "nArgs": 4,
            "cat": "special",
            "help": "slider(def,min,max) creates and polls a slider with default value 'def', minimum 'min' and maximum 'max'.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=slider(50,0,100)",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity has a numerical value, a slider is an adequate user interface. <br><br>If all three arguments of slider are integers, the resultating value is also integer; if at least one of the three is a floating point value, the result is also floating point. So slider(1,0,3) can produce any of the values 0,1,2, or 3; slider(1.0,0,3) may also produce e.g. the value 2.7. Notice: for a slider with floating point values, not all floating point values may be achievable by moving the slider by hand. The smallest step a slider can make is determined by the resolution of the screen, and the number of pixels in a slider is typically not more than, say, 100. So the number of different result values for a slider is limited to, say, 100. <br><br>Sliders are associated to cat.-I quantities, and these are varied automatically in the Pareto genetic algorithm. For integer-type sliders, the values for the associated cat.-I quantity in the Pareto genetic algorithm are only integer, whereas for a floating point-type slider, these values are floating point values. The restriction to the number of distinguishable values in relation to the screen resolution does not apply to the obtainable values in the Pareto genetic algorithm.",
            "external": "",
            "seeAlso": "check,input,button,cursorX,cursorY,cursorB,categories",
            "abbreviation": ""
        },
        "cursorX": {
            "fName": "cursorX",
            "nArgs": 1,
            "cat": "special",
            "help": "cursorX() is the x-coordinate of the cursor, restricted to the area of the plotting canvas.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "h=cursorX()",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity has a numerical value, the location of the cursor in the plotting canvas is an adequate user interface.",
            "external": "",
            "seeAlso": "check,slider,cursorY,cursorB,categories",
            "abbreviation": ""
        },
        "cursorY": {
            "fName": "cursorY",
            "nArgs": 1,
            "cat": "special",
            "help": "cursorY() is the y-coordinate of the cursor, restricted to the area of the plotting canvas.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "h=cursorY()",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity has a numerical value, the location of the cursor in the plotting canvas is an adequate user interface.",
            "external": "",
            "seeAlso": "check,slider,cursorX,cursorB,categories",
            "abbreviation": ""
        },
        "cursorB": {
            "fName": "cursorB",
            "nArgs": 1,
            "cat": "special",
            "help": "cursorB() is the button-status (down=true, up=false) of the mouse (cursor).",
            "autoMapping": "Does not support auto-mapping.",
            "example": "b=cursorB()",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity has a true/false value, the button state of the mouse in the plotting canvas is an adequate user interface.",
            "external": "",
            "seeAlso": "check,button,cursorX,cursorY,categories",
            "abbreviation": ""
        },
        "check": {
            "fName": "check",
            "nArgs": 2,
            "cat": "special",
            "help": "check(value) creates and polls a check box with default value 'value'.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=check(true)",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity is a boolean, a checkbox is an adequate user interface.",
            "external": "",
            "seeAlso": "button,slider,input,categories",
            "abbreviation": ""
        },
        "input": {
            "fName": "input",
            "nArgs": 2,
            "cat": "special",
            "help": "input(def) creates and polls an input (text) field with default value 'def'.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=input('type something')",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity is a string, an input box is an adequate user interface. Values obtained by means of the input-function, although in cat.-I, are not modified using the Pareto-genetic Optimisation algorithm. This makes them well-suited to enter constants to a script for which the values should be under user control.",
            "external": "",
            "seeAlso": "check,slider,button,categories",
            "abbreviation": ""
        },
        "button": {
            "fName": "button",
            "nArgs": 1,
            "cat": "special",
            "help": "button() creates and polls a button.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "p=button()",
            "details": "Category-I quantities are under direct control of the user. If a cat.-I quantity is a boolean that is only true at short time instances, a button is an adequate user interface.",
            "external": "",
            "seeAlso": "check,slider,input,categories",
            "abbreviation": ""
        },
        "paretoMax": {
            "fName": "paretoMax",
            "nArgs": 1,
            "cat": "special",
            "help": "paretoMax(x)=x. The quantity in the left-hand side of an expression containing the function paretoMax is registered for maximisation in Pareto-sense.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "profit=paretoMax(income-expenses)",
            "details": "Cat.-II quantities that are registered for maximisation or minimisation are taken into account in +ACCELTM+'s genetic optimisation machinery.",
            "external": "",
            "seeAlso": "SPEA,optimisation,categories,paretoMin,paretoHor,paretoVer",
            "abbreviation": ""
        },
        "paretoMin": {
            "fName": "paretoMin",
            "nArgs": 1,
            "cat": "special",
            "help": "paretoMin(x)=x. The quantity in the left-hand side of an expression containing the function paretoMin is registered for minimisation in Pareto-sense.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "waste=paretoMin(purchased-inUse)",
            "details": "Cat.-II quantities that are registered for maximisation or minimisation are taken into account in +ACCELTM+'s genetic optimisation machinery.",
            "external": "",
            "seeAlso": "SPEA,optimisation,categories,paretoMax,paretoHor,paretoVer",
            "abbreviation": ""
        },
        "paretoHor": {
            "fName": "paretoHor",
            "nArgs": 1,
            "cat": "special",
            "help": "paretoHor(x)=x. The quantity in the left-hand side of an expression containing the function paretoHor is registered for being plotted horizontally.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "waste=paretoHor(paretoMin(purchased-inUse))",
            "details": "For a valid Pareto-plot, one quantity needs to be registered for horizontal and one for vertical plotting. Although only two quantities can be registered for plotting, +ACCELTM+ can deal with more than 2 cat.-II quantities for optimisation.",
            "external": "",
            "seeAlso": "SPEA,optimisation,categories,paretoMax,paretoMin,paretoVer",
            "abbreviation": ""
        },
        "paretoVer": {
            "fName": "paretoVer",
            "nArgs": 1,
            "cat": "special",
            "help": "paretoVer(x)=x. The quantity in the left-hand side of an expression containing the function paretoVer is registered for being plotted vertically.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "profit=paretoVer(paretoMax(income-expenses))",
            "details": "For a valid Pareto-plot, one quantity needs to be registered for horizontal and one for vertical plotting. Although only two quantities can be registered for plotting, +ACCELTM+ can deal with more than 2 cat.-II quantities for optimisation.",
            "external": "",
            "seeAlso": "SPEA,optimisation,categories,paretoMax,paretoMin,paretoHor",
            "abbreviation": ""
        },
        "user functions": {
            "fName": "user functions",
            "cat": "general",
            "help": "+ACCELTM+ supports user-defined functions, featuring local quantities (a.k.a. formal arguments).",
            "autoMapping": "user defined functions are compatible with auto mapping: if the function body uses a function that supports auto-mapping, the auto mapping feature also applies in the user defined function. quantities that are mapped may be both regular ('global') quantities and local quantities.",
            "example": "mySum(x,y)=x+y introduces a function called 'mySum' that takes two arguments and returns their sum. It can be called as p=mySum(3,4), but also e.g. as q=mySum(mySum(3,4),5) or q=mySum(3+4,5)",
            "details": "In some respects user defined functions behave a bit like quantities - in the sense that they can occur in expressions. For instance myArray(x,y)=['first':x,'second':y] can occur in an expression such as p=@(myArray(3,4),'first'), correctly producing 3. In other respects, they are very different. They do not have a history, so mySum{1} is not defined. In p=mySum(mySum(3,4),5), it is impossible to say what the value of 'mySum' is: is it 7 or 12? For this reason, they don't show up in the listing in the IO / edit tab if the 'show values' option is selected. <br><br>In the same way, local quantities, such as the x and y in the above example, are a bit different from category-I,II,III or IV-quantities. For instance, again mySum(x,y)=x+y, if we have p=mySum(3,4) and q=mySum(5,6) occurring in the same script, we cannot say if x is 3 or 5. So local quantities also don't show up in the IO / edit-version as separately listable quantities.<br><br>In many respects, local quantities resemble dummies in quantified expressions. Naming conventions are to a large extent similar. Names for dummies as well as names for local quantities don't need to be unique (that is, a local quantity name can occur in several user-defined functions and/or as a name of a dummy in several quantified expressions). The following restrictions apply:<ul><li>The name of a dummy or local quantity must not occur as the name of a regular ('global') quantity;</li><li>if a user defined function has multiple local quantities, these must have different names. It is forbidden to have mySillyExample(x,x)=2*x;</li><li>if quantified expressions are nested, dummies must have different names. It is forbidden to have #(i,[1,2,3],#(i,[1,2,3],i*i,add),add).</li></ul><br><br>User defined functions allow recursion. For instance, the following function calculates the factorial: myFac(x)=cond(x<=1,1,myFac(x-1)*x). Notice that here we need the cond() form instead of the if() form: the if()-form causes both alternatives to be calculated always, and the calculation then would never end. Recursion is tricky: the following example works fib(x)=cond(x<=1,1,fib(x-1)+fib(x-2)) to calculate elements from the famous Fibonacci series, but the evaluation of fib(30) takes already more than a second on most machines. Als think about inf(x)=inf(x)+1: this pseudo-recursion is sure not to terminate. With recursion it is very easy to exceed bounds in execution time or memory usage. +ACCELTM+ uses a number of heuristics to detect and robustly handle such exceptions, but some care should be taken when using recursion.<br><br>Thinking of functions fits very well in the framework of four categories. Indeed, we can write down the appliation of a function, even before we have thought about the body (=the statements that define what the function does). Such as soldVolume=priceElasticity(price,numberPotentialCustomers). The details of priceElasticity(x,y) need not to be known, in that respect it behaves a bit as a category-IV quantity. It will therefore appear in the to-do list as long as the body is not yet given.",
            "seeAlso": "quantified expression,recursion,local quantity, formal quantity,dummy,categories",
            "external": "There is a vast amount of literature on functions, function application and related topics. A start can be found here: <a href='http://en.wikipedia.org/wiki/Function_(mathematics)'>http://en.wikipedia.org/wiki/Function_(mathematics)"
        },
        "categories": {
            "fName": "categories",
            "cat": "general",
            "help": "+ACCELTM+ is based on the notion that quantities in (quantitative) models can play 4 roles:<ul><li>Category I: choice quantities, corresponding to user interface device (slider, checkbox, button, input-field. The category-I quantities (apart from values obtained by the input()-function, which are kept constant dusring execution of the SPEA algorithm) are used as independent quantities in optimisation: they are varied (using some heuristics) to achieve Pareto-optimal values for category-II quantities.</li><li>Category-II: objective quantities. These are the 'outcomes' of the model calculation. In the case of a design model, they represent the quality (the adequateness, the goodness, the merit, ...) of the design, where a 'design' is a choice for all of the category-I quantities.</li><li>Category-III quantities: these are all constants - that is: independent quantities on which the user (designer) has no influence, but who do have influence on the category-II quantities.</li><li>Category-IV quantities: all quantities that depend on cat.-I, cat.-III or other cat.-IV quantities, and onto which cat.-II and other cat.-IV quantities depend. They are the 'intermediate' quantities that each represent small sub-mechanisms of the entire model.</li></ul>",
            "autoMapping": "",
            "example": "In the following script:<br>a=slider(10,0,20)<br>b=12<br>c=a+b<br>d=b*2<br><br>a is cat.-I, b is cat.-III, c is cat.-IV, and d=cat.-II.",
            "details": "+ACCELTM+ figures out to which category quantities belong. In the script listing in the Edit / Run script tab, for every quantity it is indicated to which category it belongs. +ACCELTM+ will put not-yet defined quantities automatically in a to-do list.<br><br>In the script listing in the Edit / Run script tab, quantities are sorted per category.",
            "seeAlso": "to-do list",
            "external": ""
        },
        "time": {
            "fName": "time",
            "cat": "general",
            "help": "For every quantity, either scalar or vector, historic values (=values that were computed in earlier evaluations, that is: at earlier timesteps) can be accessed. For a quantity x, x{n} is its value at n time steps ago. ",
            "autoMapping": "The operator {n} can only be applied to a quantity, (either scalar of vector), not to expressions. So e.g, (a+b){1} does not make sense. To obtain (a+b){1}, one should set e.g. c=a+b followed by d=c{1}.",
            "example": "To have a quantity which represents time, simply write time=time{1}+1. This means: the current value of the quantity time equals the previous value plus one. <br>To approximate the solution of a differential equation of the form df/dt=g, use 1st order Taylor expansion to write g(t)=(f(t+h)-f(t-h))/2h, or f(t+h)=f(t-h)+2hg(t). This can be simplified to f=f{2}+2*g{1} (tacitly taking h==1), or even f=f{1}+g. <br>For second order time dependecy, we get in a similar way f=2*f{1}-f{2}+g{1}",
            "details": "Notice 1: The time delay n can be arbitrary - but the result of x{n} for n which is larger than the number of evaluations thusfar is the default value. The default value for numerical quantities is 0, for Booleans it is false and for strings it is the empty string. Also, the default value will always be a scalar. So any quantity for which historic values are to be assessed, starts its lifecycle as a scalar. <br>Starting conditions typically occur in the form of x=if(time>1,functionOfX(x{1}),x0). The function 'functionOfX' may expect its argument to be a vector, and therefore encounters a type-problem for time=1. But at time=1, the expression 'x0' is returned for x. Provided that this expression is a vector, the rest of the calculation will work as expected. <br>Notice 2: functional dependencies shall not be cyclic. That is, constructions as the following are forbidden:<br>a=b+3<br>b=a-5<br>, even if thie would be algebraically feasible (such as a=b+3 followed by b=a-3). For time-delayed assessments of quantities however, this restriction does not apply: it is correct to set <br>a=b+3<br>b=a{1}+5.",
            "seeAlso": "iteration,cyclic dependency,user functions",
            "external": "ACCEL deals with time by means of recurrence; see <a href='http://en.wikipedia.org/wiki/Recurrence_relation'>http://en.wikipedia.org/wiki/Recurrence_relation</a>. Also, in stead of differential equations, ACCEL's approach to (discrete) time suggests to interpret time evolution as a <span class=\"accelEmph\">difference equation</span> rather than as a <span class=\"accelEmph\">differential equation</span>. See the same reference for an introduction to difference equations.",
            "abbreviation": ""
        },
        "sensitivity analysis": {
            "fName": "sensitivity analysis",
            "cat": "general",
            "help": "+ACCELTM+ models are functional models. Every cat.-II quantity is written as a function of cat.-I and cat.-III quantities. To get an idea of the reliability of a model, it is important to understand the sensititivies of these functional dependencies. Indeed, if a cat.-II quantity turns out to be highly sensitive for small changes in some cat.-I or cat.-III quantity, we should be very careful with drawing conclusions: since any model will contain inaccuracies, the propagation of a small uncertainty in one of the input quantities may render the outcome fully meaningless. Therefore, performing sensitivity analyses should be routine in any modelling project.<br><br>+ACCELTM+ significantly fascilitates sensitivity analysis with its built-in numerical sensitivity analysis estimation tool. The tool can be found on the tab 'analysis'. The sensitivity analysis is performed by simply clicking the button 'do sensitivity analysis'. It produces a table where the first row gives estimates for the standard deviations of each of the cat-II quantities, either in absolute values or in percentage of their expectation value. For instance, for the functional model y=x;x=10, for a standard deviation of 1 percent in x, the standard deviation in y is also 1 percent. For an absolute deviation of 0.3, the resulting deviation is also 0.3. For a functional model y=x*x; x=10, we get a relative percentage of 2, irrespective of the value of x. Indeed, let y=f(x), then delta y/y = df/dx * (delta x/x) * (x/y); df/dx = 2y, so delta y/y = 2x*x/y * (delta x/x) = 2 * (delta x /x). <br><br> Relative spreadings (either in absolute values or in percentage) in cat.-I or cat.-III quantities can be input by clicking on the current value of each (absolute or percentual) value. These spreadings are used both to estimate the standard deviation and to estimate the propagated uncertainties (see below). Switch between a(bsolute) or p(ercentual) sampling by clicking on the word 'percentual' or 'absolute' in the first row. <br><br>Every subsequent row corresponds to a cat-I or cat-III quantity, and every cat.-II quantity is a column. When both row and column correspond to numbers, the error propagation is given. In case of percentual calculation, this error propagation is given by the so-called condition number. For cat.-II quantity y and cat.-I or -III quantity x, the condition number is defined as abs((dy/dx)/(y/x)), that is: the ratio of relative changes in y and x, dy/y and dx/x. For more sensitive dependencies, the value is larger than 1. Very large values are given in red: these ask for more careful analyses whether the numerical outcomes could be trusted. In case of absolute calculation, the error propagation is given as df/dx * dx, that is: the absolute difference in output given the absolute difference in input. In the example of y=x*x; x=10, the absolute error propagation for an input difference of 1 is approximately (121-100) = 21. The approximation is due to the fact that a numerical estimate to the first derivative, df/dx is used. ",
            "autoMapping": "",
            "example": "For a model of the form y=(x1*x2*x3...)/(x4*x5*x6...), all condition numbers are 1. For a model of the form y=(x1+x2+x3+...), condition numbers are proportional to the absolute size of the x's, and their sum is 1.",
            "details": "The differential quotient dy/dx can only be numerically approximated. To that aim, x is changed a small amount. By default, this is 0.01 of its value. (1 percent). To check if this gives a stable approximation for some quantity x, one can click on the + or - in the row of that x. The percentage (listed in the column labeled %) used to estimate dy/dx is then doubled or halved; for the result to be trustworthy, the calculated condition number should not change much. The approximation used, entails that we take the average of the absolute value of the left derivative and the absolute derivative value of the right derivative. As a consequence, the estimated value of the deriviative that is computed in the apex of a function is not zero - as one might expect: it approaches zero only for dex towards 0. This is done to avoid misleadingly optimistic interpretation of the error propagation in the neighborhood of local extrema. The analytically correct value '0' that would be obtained there is meaningless in most cases.<br><br>The standard deviation dy of a function y=f(x1,x2,...xi) is calculated as the square root of the sum of squares of, for every i, the square of df/dxi * dxi. In this respect we follow <a href = 'http://en.wikipedia.org/wiki/Propagation_of_uncertainty'> http://en.wikipedia.org/wiki/Propagation_of_uncertainty </a>. To get the relative value for the standard deviation, we calculate the square root of the sum of squares of, for every i, the square of df/dxi * (dxi/xi), and divide the final result by y. So the absolute standard deviation of y=f(x1,x2)=x1+x2, for x1=1,x2=1,dx1=dx2=0.1 is 0.14; the relative standard deviation is 0.071 (indeed, setting '0.1' for both spreadings in x1 and x2 is interpreted as '0.1 percent', hence the relative spreading in x1+x2 is sqrt(2) * 0.05 percent = 0.071 percent.<br><br>To get info on the meaning of the quantity, click on the questionmark.<br><br>For cat.-I, III or II quantities that are not scalar numeric, the condition number cannot be defined. In that case, e.g. 'arg:string', or 'result:vector' is set.",
            "seeAlso": "categories,plotting dependencies,debugging,plotting dependencies,analysis",
            "external": "An introduction to senisitivity analysis is found here: <a href='http://en.wikipedia.org/wiki/Sensitivity_analysis'> http://en.wikipedia.org/wiki/Sensitivity_analysis</a>.",
            "abbreviation": ""
        },
        "to-do list": {
            "fName": "to-do list",
            "cat": "general",
            "help": "The to-do list contains the quantities that still need to be defined. As long as the to-do list is not empty, the model can not be compiled and executed.",
            "autoMapping": "",
            "example": "In an empty script, type a=b+3. The right hand expression contains a quantity b that is not yet defined; this quantity appears in the to-do list.",
            "details": "A model can be entered in the form of a complete script in the IO / Edit-tab. Alternatively, a model can be entered line-by-line. If the model is built up line-by-line, a very systematic way is to start with a cat.-II quantity, to define this in terms of cat.-IV quantities, and to subsequentially process all cat.-IV quantities until everyone of them is defined in terms of other cat.-IV quantities or cat.-I/III quantities. At any stage during this process, therefore, there will be 0 or more not-yet defined quantities. To keep track of the work that still is to be done to make the model complete, these not-yet defined quantities are collected in a so-called to-do list. This list is automatically shown as soon as there are any not-yet defined quantities; the list vanishes as soon as it is empty. By clicking on a quantity in the to-do list, this quantity is transported to the script-line input box. ",
            "seeAlso": "categories,script,IO / Edit",
            "external": "",
            "abbreviation": ""
        },
        "dependencies": {
            "fName": "dependencies",
            "cat": "general",
            "help": "+ACCELTM+ models are functional models. To keep track of the functional dependencies in a model, it is often needed for a given quantity x, to find which quantities x depends on, and which other quantities depend on x. Various provisions in +ACCELTM+ help to answer these questions.",
            "autoMapping": "",
            "example": "In the script <br>a=b+c+3<br>b=d+2<br>c=1<br>d=5<br>, a depends on b and c; b depends on d and a is dependent on b; c and d depend on nothing, et cetera.",
            "details": "In the script listing in the tab 'Edit / Run script', every line can be clicked. Clicking on any part of a script line moves the script line to the edit text field; it puts all the quantities that depend on the current quantity (say 'x') in the list 'x: arg to ...'; furher, it puts al the quantities occurring in this expression for x in the list 'Arg of x'.<br><br> Elements in the lists 'x: arg to...' and 'Arg of x' can also be clicked. Clicking on one of the quantities in these lists puts the quantity and its defining expression into the edit text field, and updates both lists.<br>If the script is not running (click on pauze to stop a running script), one can alos click on each of the quantities in the 'Results' list: for a clicked quantity in the 'Results', the same procedure appplies.<br><br>The network-tab offers a direct view to the model as a network of dependencies among quantities.",
            "seeAlso": "to-do list,cyclic dependency,categories,tabs",
            "external": "",
            "abbreviation": ""
        },
        "cyclic dependency": {
            "fName": "cyclic dependency",
            "cat": "general",
            "help": "+ACCELTM+Assumes functional models, that is: values of output quantities depend on input quantities. In that paradigm, it is forbidden to have constructions like <br>a=b+3<br>b=a-2<br> where quantities indirectly depend on themselves. This is called <span class=\"accelEmph\">cyclic dependency</span>. Cyclic dependency is even forbidden in the situation where fixed points (=sets of values that satisfy all definitions) exist, such as <br>a=b+3<br>b=a-3<br>.",
            "autoMapping": "",
            "example": "In designing the dimensions of a book, there is a relationship between text length TL, point size PS and number of pages NP of the form NP=C*TL/PS. From algebra it is obvious that also PS=C*TL/NP. However, only one of the two expressions can occur in a functional model of the book. Therefore the model maker should make up het mind: which of the two dependencies, in her view, describes most adequately the causality at hand: is the number of pages the result from choosing the point size (for instance: designing a book for elderly readers, where the points size should be a given value), or does the point size result from choosing the number of pages (for instance: designing a travel guide for backpackers, where the book should be as lightweight as possible, and therefore contain no more than some amount of pages).",
            "details": "In most cases, cyclic dependencies occur as a result of the confusion of what depends on what. If, while entering a script, a cyclic dependency happens before the script is completed, +ACCELTM+ has not yet attempted to compile the script, and cyclic dependency cannot be detected. If no more undefined quantities occur, +ACCELTM+ compiles the script. Cyclic dependency, however, is no syntax error, and therefore compilation of a script containing cyclic dependencies may succeed. Only during runtime the occurrence of a cyclic dependency can be detected.<br>In some cases, the cause of cyclic dependency relates to the notion of time: one may want to express that x at a later time step equals x at a previous time step plus some increment. This means, however, that there are two quantities: x and x{1}, with an implicit relationship between them - namely, that the value of x will be the value of x{1} at the next time step, and similar for x{n}, n>1. ",
            "seeAlso": "time,iteration,dependencies",
            "external": "",
            "abbreviation": ""
        },
        "plotting dependencies": {
            "fName": "plotting dependencies",
            "cat": "general",
            "help": "In +ACCELTM+, dependencies between any pair of numerical, scalar quantities can be graphically plotted. This is a useful device for testing the behaviour of a model-under-construction.",
            "autoMapping": "",
            "example": "Consider a model of a taxi company. One of the cat.-II quantities is the profit (P) in Euro/year; one of the cat.-III quantities is the fuel price (F) in Euro/liter. Any reasonable model should show a decreasing behaviour of P=P(F); on the other hand, F=F(P) is not defined since F does not depend on P.",
            "details": "In the tab 'analysis', there are two tables of quantities, one labeled 'Arguments', the other labeled 'Results'. All numerical, scalar quantities in the current model appear in both tables. By clicking a quantity in one of the tables, this quantity is chosen as either argument or result quantity in a graph to be plotted. The ranges of the argument and result quantity can be independently set by filling in numerical values in the 'from' and 'to'-boxes for the argument and result quantities. Values for the result quantity, by default, are scaled such that the graph fits either exactly or approximately in the vertical scale. Exact fitting happens if the checkbox 'auto scale: exact clamping' is selected. Exact scaling is nice to inspect values of minima and maxima, but the numbers are nicer if non-exact clamping is selected. +ACCELTM+ tries to do a reasonable first guess for the interval of argument-values. In particular, for cat.-I quantities that are sliders, the interval of the slider is taken as interval of argument quantity. Take care when adjusting the from- and to-values of an argument quantity that values may be entered for which the model is not defined. In that case, error message may or may not be produced, depending on the working of the script.<br><br>For argument quantities that correspond to sliders with a nominal domain (in the taxi-\"example\": the car brand),the model doesn't make sense for any other values than the discrete range of integers, obtainable by the slider. In such cases, the plot will consist of discrete dots only.<br><br>The graph is automatically plot again whenever either the argument value, the range value, or any of the from- or to-values is changed.<br><br>An alternative view to dependencies is offered by means of the network tab (see the tabs-documentation). This view depicts the model as a network of dependencies among quantities.",
            "seeAlso": "dependencies,cyclic dependency,sensitivity analysis,debugging,analysis,tabs",
            "external": "See <a href='http://en.wikipedia.org/wiki/Graph_of_a_function'> http://en.wikipedia.org/wiki/Graph_of_a_function </a> for more background on graphs of functions.",
            "abbreviation": ""
        },
        "graph plotting": {
            "fName": "graph plotting",
            "cat": "general",
            "help": "All quantities computed by +ACCELTM+ can be visually represented by graphs. Grap-plotting is done by the +DESCARTESTM+ subsystem.",
            "autoMapping": "",
            "example": "plot([graph1,graph2])<br>graph1=[ctrl1,data1,data2]<br>graph2=[ctrl2,data3]<br>ctrl1=[plotType:'line',x:[mode:'intp'],y:[mode:'data',ref:1],width:[mode:'data',ref:2],col_r:[value:200]]<br>ctrl2=[plotType:'radar',phi:[mode:'shift',ref:1]]<br>data1=[..,..,..,..]<br>data2=[..,..,..,..]<br>data3=[..,..,..,..]",
            "details": "There is a single function available for all forms of data visualisation: the function plot(). It takes an array where every element is one graph. A graph is an array where the first element is a control vector. Further elements are optional; every further element is an array of scalar numerical data.",
            "seeAlso": "descartes,control string,plot format",
            "external": "",
            "abbreviation": ""
        },
        "units and unit checking": {
            "fName": "units and unit checking",
            "cat": "general",
            "help": "Quantities in +ACCELTM+ can be associated to units. Expressions with units can be checked, and quantities for which no units have been provided will receive units automatically. Unit checking, when enabled, takes place automatically when the script is viewed in the IO/ Edit tab. <br><br>In order to enable unit checking, check the checkbox 'check units' in the tab 'IO /Edit'.",
            "autoMapping": "",
            "example": "a=3;kg<br>b=5;m<br>c=2;liter<br>x=a*b/c<br><br>produces a numerical outcome of 7.5. The unit of this outcome is calculated as kg.m/liter.",
            "details": "A unit is any expression of the form numerator or numerator/denominator, where both numerator and denominator consist of zero or more factors. Factors can be any string consisting of letters only, optionally followed by a positive integer. Factors are separated by points (.). In case of no factors in the numerator, write '1' (one). <br><br>Units of compound quantities are recognised, e.g. a=[p,'x':[q,r]];[kg.m/s2,'x':[liter,liter2]]. Notice that the names used to label properties in a quantity must occur identical in the unit for that quantity; vectors with unnamed elements have a unit that contains the same amount of elements.<br>Unit checking works for binary operations such as + and max: units of quantities must be equal. It also works for operators assuming unit-less arguments such as sin() and or. The approporiate algebra for multiplying and dividing units is applied. Also the sqrt function is handled correctly: if the unit of p is m2.kg2, the unit of sqrt(p) is m.kg.<br><br>Unit checking takes place when the view switches from the Edit / run script-tab to the IO / Edit tab. Some apparent unit-errors relate to problems with initialisation. For instance, checking the unit of a=a{n}+p, where p has a unit, can only take place after at least n iterations; prioir to that time, a will take a default value (0) with undetermined unit.<br><br>Errors against unit checking don't prevent the script from running. Some errors against unit syntax, however, are considered as compile errors; these need to be fixed before the script can run.<br><br>Unit information is propagated from categories I and III to categories IV and II. Units for quantities in categories IV and II are overwritten by deduced units; units for quantities in categories I and III cannot be deduced from units of quantities in categories IV or II.<br><br>Notice that, to get units correct, it may be necessary to introduce value-less quantities (as opposed to dimensionless quantities). Example: the amount of glasses of beer, G, with unit 'glass' to be served to a group of friends is given by the formula R * F where R is the number of rounds (unit: 'round') and F is the number of friends (unit: 'friend'). However, this expression is dimensionally flawed. It needs multiplication with a quantity with unit glass/friend.round and value 1. Indeed, this signifies that in each round, every friend consumes one glass of beer. Similarly, there can be value-less quantities to make correct expressions where where quantities are added or subtracted. An example is the max() function. In order to ensure a quantity q with unit 'u' to be positive, we may write min(0,q). But this only is correct if the value 0 has unit 'u' as well: the 0 is a value-less, but not dimensionless quantity with unit 'u'.",
            "external": "",
            "seeAlso": "scalar,vector",
            "abbreviation": ""
        },
        "demo": {
            "fName": "demo",
            "cat": "general",
            "help": "The best way to get familiar with +ACCELTM+is by playing with scripts that already work and do something meaningful. A collection of demo scripts can be found in the right most table on the tab Help / Demo; merely selecting a title should load the script and start it. The full script text can be inspected in the IO / Edit screen.<br><br>In case you want your own script to be shared with other users, perhaps to hand it in as homework, you should click the button labeled 'submit'. Then the script is stored in a database, and you receive a unique link (a URL); going to that link in a browser supported by +ACCELTM+ runs your script. Notice(1): In some cases you might want to type in the link you receive in the address bar of your browser. This is inconvenient for very long URL's; therefore +ACCELTM+ constructs the unique name on the basis of a string (=a name) you provide. Suppose you want to call your script 'myDemo', then you should type in this name. In case, say, two people before you proposed the same name, the name of your script will be 'myDemo_2', and the link will be something like 'www.keesvanoverveld.com/Accel/accel.htm?link=myDemo_2' - which is not too bad in to type in yourself. Notice(2): scripts are stored only for a limited amount of time on the server (aqbout one week). For preserving scripts permanently, you should not rely on this service, but store scripts as text-files on your local computer.",
            "autoMapping": "",
            "example": "",
            "details": "",
            "seeAlso": "IO / Edit,help system",
            "external": "",
            "abbreviation": ""
        },
        "help system": {
            "fName": "help system",
            "cat": "general",
            "help": "If you are reading this text, it is likely that you have at least some working knowledge of +ACCELTM+'s help system. For completeness' sake, we explain the full help system here.",
            "autoMapping": "",
            "example": "",
            "details": "There are four ways to access a help topic.<ul><li>Select a help category from the left most table on the tab Help / Demo. Categories are for instance 'algebra' (explaining the algebraic functions), 'optimisation' (explaining the optimisation methods) et cetera. When a category is clicked, a list of 'Help details' is shown. Clicking on one of the help detail topics shows the actual lemma. Notice that help detail topics in white refer to functions in the +ACCELTM+ script language; help detail topics in blue are general subjects. </li><li>Typing in a search string in the text input field, upper left, and optionally clicking the 'search' button filters all help detail topics containing the search string - irrespective of the help category. Again selecting a help detail topic presents the actual help text.</li><li>Every help lemma contains a section 'see also'. Terms found there can be clicked; they appear as search strings in the search text input field, and the matching help detail topics are automatically shown.</li><li>If anything else fails, you can click the button 'ask for help via mail': in that case you can compose a help text that can be sent off to the +ACCELTM+system administrator.</li></ul>Apart from browsing through the help lemma's, an efficient way to become familiar with +ACCELTM+is to load demo's and to study, play and modify them.",
            "seeAlso": "demo",
            "external": "",
            "abbreviation": ""
        },
        "genetics": {
            "fName": "genetics",
            "cat": "general",
            "help": "A broad class of models has the purpose to optimise something. That means: cat.-I quantities should be given such values that certain cat.-II quantities are optimal (maximal or minimal). Since models can be extremely varied, including non-linear, non-continuous and multiple-objective models, there are very few sufficiently generic optimisation methods. One method that does apply in virtually all circumstances is <span class=\"accelEmph\">genetic</span> or <span class=\"accelEmph\">evolutionary</span> programming. ",
            "autoMapping": "",
            "example": "The biological variety in living species is believed to have resulted from genetic optimisation according to the principle of survival of the fittest in a heterogenous population. Genotype roughly matches with our notion of cat.-I quantities, phenotype roughty with cat.-II quantities.",
            "details": "The essence of genetic optimisation is, that rather than a single solution that should be optimal, we operate on a population of sample solutions that is sufficiently varied. Some individuals in that population will be fitter than others, and the chance for next generation individuals to resemble the fitter ancestors is somewhat larger than for non-fit individuals. The process is initiated by a fully random population, that is: a population where the values for all cat.-I quantities for each individual are randomly chosen. Fitness is determined by means of <span class=\"accelEmph\">domination</span>. <br><br>Domination is the relation between two individuals where values of <span class=\"accelEmph\">all</span> cat.-II quantities of one individual values are better than those of the other. 'Better' here means: larger for a quantity that needs to be maximised, and less for a quantity that needs to be minimised. <br><br>This introduces the notion of <span class=\"accelEmph\">strength</span>. Strength is a measure for the fitness of a quantity. Strength is minus the number of individuals whom an individual is dominated by. Non-dominated individuals have strength=0; all dominated individuals have lower strengths. To construct a next generation's population, all non-dominated individuals are preserved. These are said to form the <span class=\"accelEmph\">Pareto-front</span>. Individuals not on the Pareto-front are replaced by new individuals, where a number of heuristics can be used to form a new individual. After a number of generations, it is assumed that the Pareto front moves in the direction of increasingly stronger (fitter) individuals.",
            "seeAlso": "Pareto,dominance,population,paretoMax,paretoMin,SPEA",
            "external": "One of the original papers of Zitzler and Thiele, introducing the Strength Pareto Evolutionary Algorithm is <a href='http://www.tik.ee.ethz.ch/sop/publicationListFiles/zlt2001a.pdf'>http://www.tik.ee.ethz.ch/sop/publicationListFiles/zlt2001a.pdf</a>",
            "abbreviation": ""
        },
        "Pareto - general": {
            "fName": "Pareto - general",
            "cat": "optimisation",
            "help": "In a population that is used to optimise certain criteria (expressed as minimum or maximum conditions on cat.-II quantities), the non-dominated individuals need to be preserved whereas dominated indiviuals can be replaced by others. ",
            "autoMapping": "",
            "example": "",
            "details": "For replacing individuals, a number of heuristics is implemented in +ACCELTM+:<ul><li>Random:  all cat.-I quantities receive random values within the ranges of the associated sliders. Boolean values are randomly set to true or false.</li><li>Arb(itrary) mutant: an arbitrary cat.-I quantity takes on a random value.</li><li>Close mutant: an arbitrary cat.-I quantity takes on a value that is close to the current value. 'Close' is taken relative to the range of admitted values for the quantity.</li><li>Cross over: a new individual is constructed by selecting two individuals on the Pareto front, and randomly selecting the values for the cat.-I quantities either from one or from the other 'parent'. This resembles the biological phenomenon of sexual procreation.</li><li>Binary tournament: two random individuals, not on the Pareto front, are selected. For both their strength is calculated (=minus the number of individuals they are dominated by), and the stronger of the two is chosen as a new individual.</li></ul>Each of these five processes has a probability, which can be specified with the five lower most sliders on the Genetic Optimisation tab. A new population is constructed by first selecting all individuals on the Pareto front, and next replacing all other individuals by applying one of the above heuristics, applying relative chances according to the specified settings of the respective sliders.",
            "seeAlso": "Pareto,dominance,population,paretoMax,paretoMin,SPEA",
            "external": "Evolutionary algorithms in general are widely applied. An overview can be found here: <a href='http://en.wikipedia.org/wiki/Evolutionary_algorithm'>http://en.wikipedia.org/wiki/Evolutionary_algorithm</a>.",
            "abbreviation": ""
        },
        "SPEA": {
            "fName": "SPEA",
            "cat": "optimisation",
            "help": "The entire optimisation process consists of a number of steps. These are outlined below.",
            "autoMapping": "",
            "example": "For a practical application, see the demo file 'taxiCompanyPareto.txt'",
            "details": "<ul><li>Make sure there is an executable script containing at least one cat.-II quantity and one cat.-I quantity.</li><li>In the script, determine what should be done to the cat.-II quantities: should they be maximised or minimized? Register quantities for maximisation or minimisation by the functions paretoMax and paretoMin. </li><li>In order to get a visual impression (and the option to interactively interrogate individuals), there should be a graphical Pareto plot. This needs one cat.-II quantity to be plotted horizontally and one to be plotted vertically. The functions paretoHor and paretoVer can be used to specify which quantities should be plotted.</li><li>Specify the size of the population using the top most slider (labeled 'population size') on the Genetic Optimisation tab. The ideal population size is determined by the speed of the computer: the larger the population, the bigger the chance for extreme optima, but the more computational resources are required.</li><li>Nest, specify the number of generations to iterate. Every click on the button 'next generations' does a full series of iterations. This amount is specified by the slider labelled 'nr. new generations'.</li><li>Next click the button 'init SPEA'. This produces a random first generation. Individuals are visualised as little blue dots. Individuals on the Pareto-front are larger red dots.</li><li>Next click the button 'next generations' to have an ordered amount of next generations. Watch the Pareto front moving in the direction of increasingly fitter solutions.</li><li>For better usage of the drawing area of the Pareto plot, buttons 'zoom in' or 'zoom out' may be clicked.</li><li>Once the Pareto front has stabilized, further improvement may be obtained by 'post tuning' (see elsewhere).</li><li>Individual solutions may be interrogated by clicking on a solution (=a blue, or in most case: a red dot); the cat.-I settings of a solution may be moved to the default settings for the relevant cat.-I quantities.</li></ul>",
            "seeAlso": "Pareto,dominance,population,paretoMax,paretoMin,paretoHor,paretoVer,SPEA,demo",
            "external": "",
            "abbreviation": ""
        },
        "post tuning": {
            "fName": "post tuning",
            "cat": "optimisation",
            "help": "After a number of generations, the Pareto front as it is estimated by the SPEA algorithm will typically stabilize: it does not further improve. In such cases, howver, significant progress sometimes can be achieved by switching to another strategy: <span class=\"accelEmph\">post tuning</span>.",
            "autoMapping": "",
            "example": "",
            "details": "The essence of genetic algorithms, as opposed to standard (local) analytic optimisation methods is, that an entire population is calculated in order to have a larger chance to cover 'niches' in the solution space where local optima might be found. If the evolutionary process does no longer make progress, a local strategy may be advantageous. In a local strategy, every individual solution on the Pareto front is processed. All cat.-I quantities of such a solution are varied, one by one, to see if dominance in the cat.-II quantities can be achieved. That is, if a new solution can be found that dominates the original solution ('domination' meaning, that the new solution is better in all cat.-II quantities than the old one). If such an improvement can be found, attempts are repeated for this solution until no further optimisation are obtained. <br><br>Notice that, by treating solutions on the Pareto front individually, they no longer need to form a Pareto front. Indeed, it is possible that a solution that could make significant improvmenet now dominates on e of the other solutions that were originally on the Pareto front. It is therefore necessary after a round of post-tuning to at least calculate one new generation of the entire population to ensure that the most recent Pareto front is attained.<br><br>Depending on the structure of the solution space, post-tuning can be a length process. It is therefore possible to interrupt post tuning. To this aim, the function of the button 'post tune' changes during the actual tuning process into 'stop tuning'.",
            "seeAlso": "Pareto,dominance,population,paretoMax,paretoMin,paretoHor,paretoVer,SPEA,demo",
            "external": "",
            "abbreviation": ""
        },
        "front": {
            "fName": "front",
            "cat": "optimisation",
            "help": "Ideally, the Pareto front contains a relative small portion of the entire population. First, this enables a large amount of individuals to actively mutate, so that a broad coverage of the entire solution space is achieved; further, multiple closely distributed Pareto-solutions are mainly redundant.",
            "autoMapping": "",
            "example": "",
            "details": "The chance for an individual to be on the Pareto front increases drastically with the number of cat.-II quantities. Indeed, the more cat.-II quantities, the smaller the chance to be dominated, and therefore the bigger the chance <span class=\"accelEmph\">not</span> to be dominated. If the fraction of individuals being on the Pareto front is too large, the evolutionary process comes to a halt: indeed, since the population size is constant, there will be too few individuals to mutate. In that case it can help to maximize the fraction of individuals on the Pareto front. This means that an individual who is not dominated, and who therefore should be part of the next generation, is deliberatly mutated (and therefore taken out of the next generation). Although this strategy stimulates a large variability, it introduces the risk that the progress of the Pareto front is no longer monotonous: it is possible to 'loose' good solutions. The slider 'max. percentage on front' can be used to set the maximum fraction of individuals that are allowed to be on the Pareto front. With as few as two or three cat.-II quantities, it should not be necessary to use this intervention.",
            "seeAlso": "Pareto,dominance,population,SPEA",
            "external": "",
            "abbreviation": ""
        },
        "modifying script": {
            "fName": "modifying script",
            "cat": "optimisation",
            "help": "Once a Pareto run has completed, it can be adviseable to promote one of the Pareto solutions to a default solution, for instance to do a sensitivity analysis in the neighbourhood of this new default.",
            "autoMapping": "",
            "example": "",
            "details": "Every individual solution in the Pareto image can be clicked. This produces a message with all information for that solution (all values for cat.-I and cat.-II quantities), plus the option to take these cat.-I values as new defaults. If this option is chosen, the script is actually modified. In particular, all slider expression of the form quantity=slider(default,low,high) get as their new value for 'default' the valua as in the selected solution.",
            "seeAlso": "Pareto,dominance,population,SPEA",
            "external": "",
            "abbreviation": ""
        },
        "iteration over time": {
            "fName": "iteration over time",
            "cat": "general",
            "help": "+ACCELTM+scripts can be used to model processes that take place over time. In particular it is possible to execute a script over a given amount of time steps in stead of only once.",
            "autoMapping": "",
            "example": "Suppose a model represents a business that is intended to reach a break-even point after some years: after an initial phase of negative profit, profits should become positive once initial investments have been written off. In this case, the script should represent one year, where the assets at the beginning of the year are taken to be the assets at the end of the previous year. Having the model run for, say, 10 successive rounds gives an estimate for the assets after 10 years. By considering only the result after these 10 time iterations, SPEA optimisation can be done where every individual represents a complete business history of 10 years.",
            "details": "Normally, one evalutation of an +ACCELTM+ script starts with setting all quantities to zero, and leaving the hisotric values of all quantities untouched. In this way, a non-time dependent model executes exactly once every round, and in a time dependent model, time keeps running. <br><br>This default behaviour, however, only applies if the iteration counter (= the numerical stepper in the tab Edit / Run script, next to the pauze button), is set to its default value 0.<br><br>If this stepper is set to, say, n, n&gt 0, the quantities are only set to zero, and the history is only erased, once every n iterations; the results are published at the end of these n iterations. <br><br>To see this working, try the following script: <br>b=a<br>a=a{1}+slider(0,1,10)<br>With the stepper set to 0, the result is an ever increasing number; with the stepper set to n, the result is the product of n and the slider value - indeed, we emulate a multiplication as a repeated addition.<br><br>When a script is executed on behalf of the SPEA optimisation, the setting of the iteration counter is taken into account, and every individual solution in the Pareto plot is the result of an iterated calculation. Obviously, for large numbers of iterations, this can signoficantly slow down the performance.",
            "seeAlso": "time,SPEA",
            "external": "",
            "abbreviation": ""
        },
        "IO / Edit": {
            "fName": "IO / Edit",
            "cat": "general",
            "help": "A script can be entered in two ways: in the Edit / Run script-tab, script lines are entered one-by-one; after every entered line, +ACCELTM+ checks if the script represents an executable model (that is: there are no undefined quantities in the to-do list, and the script is free of syntax-errors), and the script starts running. The other possibility is to type a complete script in the text area in the IO / Edit tab (or, equivalently, load a demo script from the right most table on the Help / Demo tab). In the case where a script is typed in on the text area in the IO / Edit tab, checking for completeness and checking for correct syntax only start when the run-button above the text area is clicked. A downloaded demo-script should run automatically when loading is complete.",
            "autoMapping": "",
            "example": "",
            "details": "In the IO / Edit tab, the text-area view of the script serves three purposes: <ul><li>For a complete overview, the lines are given at full length, including comment lines (script lines may be truncated in the listing in the Edit / Run script tab; the listing in the Edit / Run script tab shows no comment texts). The full view allows extensive editing without immediate consequence for the running calculation: as soon as anything changes in the text area, the running calculations are put on hold. (This can be seen since the caption of the 'pauze' button changes into 'run').</li><li>The script view in the IO / Edit tab can be used to show instantaneous values of all quantities. Click the button 'Show / hide values to flip between a view with values given and without. Values are given in the same format as comment texts (that is, preceded by two slashes). In this way, values at several instances of the execution can be collected in the same script.</li><li>+ACCELTM+, as well as any other javascript application, has no possiblities to read or write information to the local computer's file ssystem. It is possible, however, to copy and paste text from text areas. In this way a downloaded or typed-in script can be saved as an ordinary text file on the local computer: merely select all text in the text area and (on Windows machines) press ctrl-C (Mac: apple-C) to copy the current script into the copy-n-paste buffer. Next paste (ctrl-V/apple-V) the text into any text editor and save the contents as a text file. Similarly, a script can be restored: load the script in a text editor, select all text and copy; next select the contents of the text area in the IO / Edit tab and paste: the contents of the text area will be replaced by the new script. </li></ul>",
            "seeAlso": "run,pauze,edit,saving,restoring,syntax",
            "external": "",
            "abbreviation": ""
        },
        "saving and restoring scripts": {
            "fName": "saving and restoring scripts",
            "cat": "general",
            "help": "There are no file load or file save options in +ACCELTM+. Saving and restoring scripts takes place by copying and pasting text to and from the text area view in the IO / Edit tab.",
            "autoMapping": "",
            "example": "",
            "details": "+ACCELTM+, as well as any other javascript application, has no possiblities to read or write information to the local computer's file ssystem. It is possible, however, to copy and paste text from text areas. In this way a downloaded or typed-in script can be saved as an ordinary text file on the local computer: merely select all text in the text area and (on Windows machines) press ctrl-C (Mac: apple-C) to copy the current script into the copy-n-paste buffer. Next paste (ctrl-V/apple-V) the text into any text editor and save the contents as a text file. Similarly, a script can be restored: load the script in a text editor, select all text and copy; next select the contents of the text area in the IO / Edit tab and paste: the contents of the text area will be replaced by the new script. ",
            "seeAlso": "",
            "external": "",
            "abbreviation": ""
        },
        "run - pauze": {
            "fName": "run - pauze",
            "cat": "general",
            "help": "+ACCELTM+ can be in two modes: run and pauze. In run mode, the script is repeatedly executed, giving real-time response to sliders and other input devices, performing a dynamic simulation and/or updating visual output. In pauze mode, the execution is halted. In case debugging was enabled, the debug-output window is minimized to the task bar, but it may be opened for inspection.",
            "autoMapping": "",
            "example": "",
            "details": "Run mode is only possible with a script that is executable, that is: a script without any undefined quantities (no to-do list) that is syntactically correct. When entering a script line-by-line in the Edit / Run script tab, +ACCELTM+continuously checks if this is the case; if so, run mode is automatically entered. <br><br>When entering a script via the IO / Edit tab, run mode can be entered by clicking the 'run' button.<br><br>During run mode, the script can be navigated (browsing through the listing on the Edit / Run script tab, scrolling through the script in the IO / Edit view, clicking on quantities in the various arguments lists in the Edit / Run script tab). There is one restriction: the list of results in the Edit / Run script tab, which is dynamically refreshed at every script evaluation, cannot be browsed or clicked when the script is running.<br><br>Pauze mode is entered in one of the following ways:<ul><li>Clicking on the button labeled 'pauze' (this button sits both in the Edit / Run script tab and in the IO / Edit tab; it is physically the same button as the 'run'-button with a changed button caption);</li><li>Modifying the content in the text-screen view of the script in the IO / Edit tab;</li></ul>In most cases, when +ACCELTM+ is in the pauze-state, it can be made to run again by clicking the run-button. In exceptional cases, the 'pauze'-button does not automatically change into a 'run'-button. This happens for instance if a non-recoverable runtime exception occurs. In that case +ACCELTM+ assumes that something needs to be adjusted in the script. Merely click on the left hand side of one of the quantities in the script listing in the Edit / Run script tab; this makes the script line appear in the text input box. Press enter (perhaps after having performed some adjustment). If the resulting script is complete and correct, +ACCELTM+ automatically will enter run-mode again. In case +ACCELTM+ does not go back to run-mode, recover the script and re-load +ACCELTM+ as explained in the lemma 'panic'",
            "seeAlso": "IO / Edit,runtime exceptions,debug,panic",
            "external": "",
            "abbreviation": ""
        },
        "comment": {
            "fName": "comment",
            "cat": "general",
            "help": "A model is only meaningful if it can be interpreted. The interpretation of a model is human-readible text, explaining the meaning of quantities and relations, and listing important assumptions. This text is called <span class=\"accelEmph\">comment</span>. Comment text is not part of the script, but it is crucial to understand the script.",
            "autoMapping": "",
            "example": "This is an example of using comment:<br>green=slider(10,0,100)<br>// a is the percentage of products painted green; default is 10.<br><br>",
            "details": "Comment text are visible in the IO / Edit tab view of the script. A comment text line starts with two slashes. Comment text lines can only be entered in the IO / Edit view. <br><br>Comment texts are used to annotate quantities in various lists (the argument list and the argument-of list). Furthermore, comments are used to provide tooltips for user interface widgets such as sliders and checkboxes. Also to aid the user of a script therefore, well-chosen comments are crucial.<br><br>A special case of comment text is the instantaneous value of a quantity. These instantaneous values can be added to the comment of a script by clicking the button 'Show/hide values' in the IO / Edit tab. This button works as a toggle: it alternatingly switches the value-view on or off.<br><br>Comment texts - either comment text that where entered by the author, or comment texts showing the instantaeous values of script quantities - form an integral part of the script. They should be saved and restored together with the actual script lines.<br><br>A comment line that takes the form of [['n':'name','x':number,'y':number],[...],...] is interpret as a prescription of the locations of the nodes (quantities) in a model when depicted as a network. Such a comment field is automatically added at the end of the script when a listing is made. Saving and restoring the script including this trailing comment line makes the network appear the same as a previous time, for easier inspection.",
            "seeAlso": "IO / Edit,editing,user interaction,tooltips",
            "external": "",
            "abbreviation": ""
        },
        "runtime exceptions": {
            "fName": "runtime exceptions",
            "cat": "general",
            "help": "Not all mathematical calculations can be correctly executed. Division by zero is a notorious example. The event where, at runtime, an impossible mathematical operation occurs is called a <span class=\"accelEmph\">runtime exception</span>.<br>A runtime exception interrupts the running evaluation; in most cases, a message explaining the cause appears, and result quantities show the text 'STACK PROCESSING INTERRUPTED'. The run/pauze mode does not automatically switch back to 'run', since in most cases some intervention is needed in the script to get things 'back on track'. Click on one of the problematic quantities in the result table, and navigate to the problem in the script. Doing so will bring the script line(s) to be edited into the text input field in the Edit / Run script tab. After fixing any issues, type 'enter', and +ACCELTM+ will atempt to compile the (modified) script. If this succeeds, the mode switches back to 'run' again. <br><br><span class=\"accelEmph\">Notice: after the occurrence of a runtime exception, the state cannot be brought back to 'run' via the IO / Edit tab: interventions need to be done via the Edit / Run script tab</span>.",
            "autoMapping": "",
            "example": "",
            "details": "",
            "seeAlso": "run - pauze,panic",
            "external": "",
            "abbreviation": ""
        },
        "panic": {
            "fName": "panic",
            "cat": "general",
            "help": "+ACCELTM+ is in one of two states: run or pause. In most circumstances, transition between these two states is fluent: either manually by clicking the run-pauze buttons, by changing something in the IO / Edit tab-view of the script, by entering a script line that makes a script complete, or as a result of dealing with a runtime exception (e.g., divide by zero). There can be rare circumstances, however, when +ACCELTM+ seems to be unable to enter the run-state. The system seems to be frozen. In such circumstance, it is important not to loose the current script. Follow the procedure below:<ull><li>Switch to the IO / Edit tab.</li><li>Select all text in the text area.</li><li>Press ctrl-C (or on Mac: apple-C).</li><li>Open a text editor.</li><li>Press ctrl-V (or on Mac: apple-V). This pastes the text into the text editor.</li><li>Save your script on the local computer.</li><li>Close the browser tab running +ACCELTM+.</li><li>Reopen the web page running +ACCELTM+.</li><li>Select the IO / Edit tab.</li><li>Paste the text (from the preserved script) into the text area.</li><li>Cick the 'run'-button to try to get the script running, or analyse the problems with the script if it refuses to run.</li></ul>",
            "autoMapping": "",
            "example": "",
            "details": "",
            "seeAlso": "run - pauze,runtime exception",
            "external": "",
            "abbreviation": ""
        },
        "editing": {
            "fName": "editing",
            "cat": "general",
            "help": "A script can be edited in one of two ways: a line-by-line approach in the Edit / Run script tab, or a full script approach in the IO / Edit tab.",
            "autoMapping": "",
            "example": "",
            "details": "The text area in the IO / Edit tab gives a full text view on the script, similar as in simple text editors. The script can be edited as any standard ASCII text; after the script is thought to be complete, click the 'run'-button to get the script checked for completeness, compiled, and - if no problems are detected, run. <br><br>The script in the IO / Edit tab consists both of executable script lines - that is, lines in the form of 'quantity'='expression', where the expression defines the quantity, or comment lines - that is, lines starting with //, containing human readable text to clarify the preceding executable script line. <br><br>In case of detected problems (e.g., undefined quantities or syntac errors), +ACCELTM+switches to the Edit / Run script tab to help fixing the problem.<br><br>Editing a script in the Edit / Run script tab takes place on line-by-line basis. After typing 'enter' in the input text field on the top of the Edit / Run script tab, the current contents of this text field is considered to be a script line, defining the quantity that occurrs before the '='-sign. If such a quantity was defined before, the new script line overwrites the earlier definition. Next +ACCELTM+ checks to see if there are any undefined quantities (that is, a to-do list). If not, it checks the syntax of all expressions, and if no errors are found, it switches to the run mode, evaluating the script. Script lines can be removed from the script by clicking on the red 'delete'-text in the script listing in the Edit / Run script tab.",
            "seeAlso": "run - pauze,syntax",
            "external": "",
            "abbreviation": ""
        },
        "syntax": {
            "fName": "syntax",
            "cat": "general",
            "help": "Every expression in a script needs to comply with the syntax of the +ACCELTM+ script language.",
            "autoMapping": "",
            "example": "",
            "details": "This language is given by the following grammar:<ul><li>expr ::= scalarExpr | vectorExpr</li><li>scalarExpr ::= scalarTerm | scalarArith</li><li>scalarArith ::= scalarBinArith | scalarUniArith</li><li>scalarUniArith ::= '-' expr | '+' expr | '!' expr</li><li>scalarTerm ::= scalarVar | scalarBrackets | scalarFunc | scalarConst | scalarQuant </li><li>scalarFunc ::= functionName '(' commaList ')'</li><li>predefinedConstant ::= PI | E | true | false</li><li>scalarConst ::=number | string | predefinedConstant</li><li>string ::= '\"'char* '\"' | \"'\"char * \"'\"</li><li>scalarVar ::= scalarDelayedVar | scalarAtomicVar</li><li>scalarDelayedVar ::= scalarAtomicVar '{' scalarExpr '}'</li><li>scalarAtomicVar ::= (element of symbol table)</li><li>scalarBrackets ::= '(' expr ')'</li><li>vectorExpr ::= '[' vectorArgList ']'</li><li>scalarBinArith ::= expr | binOp | expr</li><li>binOp ::= '+' | '-' | '/' | '%' | '<=' | '<' | '>=' | '>' | '==' | '!=' | '&&' | '||' </li><li>commaList ::= '' | expr ',' commaList | expr</li><li>vectorArgList ::= '' | vectorElem ',' vectorArgList | vectorElem</li><li>vectorElem ::= \"'\" char* \"'\" ':' expr |  char* ':' expr | expr</li><li>scalarQuant ::= '#(' freshId ',' scalarExpr ',' expr ',' functionName ')'</li></ul>   ",
            "seeAlso": "run - pauze,edit",
            "external": "",
            "abbreviation": ""
        },
        "quantified expression": {
            "fName": "quantified expression",
            "cat": "general",
            "help": "A quantified expression is an expression with an implied iteration.",
            "autoMapping": "",
            "example": "a=#(i,[1,2,3,4],i*i,add) is the sum of the squares of the numbers 1 to 4",
            "details": "A quantified expression takes the form #(dummy,domain,expression,operator). <ul><li>dummy is the fresh name (=not a name that occurs as a quantity in the script, or a dummy from an encompassing quantified expression) of a quantity, used to iterate over the set 'domain'. The expression 'expression' is evaluated for every value of the dummy, and the resulting values are aggregated using the operator 'operator'.</li><li>domain is a value or a vector of values. If it is a single value, this is the only value taken by 'dummy'. If it is a vector, 'dummy' successively takes each of the values of 'domain'. Notice: it is allowed that values of 'domain' are themselves vectors; in that case, 'dummy' will also be a vector. </li><li>expression is an arbitrary expression returning a value. This expression typically will depend on 'dummy'. It is allowed that 'expression' contains other quantified expressions. </li><li>operator is a 2-argument function for which a so-called bottom value exists. A bottom value is the value that is returned when the function is applied to an empty set. The following functions have bottom values:<ul><li>add:0</li><li>multiply:1</li><li>and:true (corresponds to the ALL-quantor in predicate calculus)</li><li>or:false (corresponds to the EXISTS-quantor in predicate calculus)</li><li>max:- infinity</li><li>min:+ infinity</li><li>vAppend:[]</li></ul></ul>",
            "seeAlso": "auto-mapping,quantor",
            "external": "Quantified expressions are best known in predicate calculus: the all- and exist-quantors are examples. In algebra, the summation or repeated product are also examples of quantified expressions. In <a href='http://en.wikipedia.org/wiki/Quantification#Mathematics'>http://en.wikipedia.org/wiki/Quantification#Mathematics</a>, an introduction to quantors is given.",
            "abbreviation": "In mathematics, various \"abbreviation\"s are common. For summation and product, for instance, the capital sigma and pi-notations are used, where the domain is often indicated as subscripts."
        },
        "tabs": {
            "fName": "tabs",
            "cat": "general",
            "help": "The various modes for operating of +ACCELTM+ can be accessed by each of the 8 tabs.",
            "autoMapping": "",
            "details": "The tabs have the following functions: <ul><li>Intro: this gives a brief introduction to the main features of the +ACCELTM+system.</li><li>Edit / Run script: this tab allows line-by line entering or editing a script. Scripts can be run, and quantity dependencies can be traced. Graphical output is given on a small plot screen.</li><li>Help / Demo: this gives access to the +ACCELTM+ help system, including a free text search on help topics and an extensive list of demo-scripts.</li><li>Io / Edit: this tab contains a text-area where script (including comment) can be entered. Copy-n-paste functionality can be used to offload scripts in the form of text files for saving into a file or text processing.</li><li>Analysis: in order to debug and analyse script, various tools are made available such as automatic sensitivity analysis and visual plotting dependencies between quantities.</li><li>Genetic Optimisation: this tab contains the user interface for a generic Pareto-based multi-objective optimisation environment.</li><li>Simulation - no script: this gives the functionality to run an (interactive) script that produces visual output on a larger plot screen. Script editing and quantity tracing facilities are not supported on this tab.</li><li>Network: this gives a graphical impression of the model. Every quantity is a node (dot); dependencies are lines between quantities. Nodes can be clicked to show the quantities that depend on it, and quantities on which this quantity depends. In models without time-delays operators, the convention holds that influence propagates from left to right. On the far left, the cat.-I and cat.-III quantities reside, the cat.-II quantities reside far right. The network allows rearranging the nodes for improved clarity, but these constraints are maintained. In models with time delay-operators, cyclic dependencies may occur: a quantity may depend on earlier versions of itself. Therefore, directions of dependencies that relate to time delays are not constrained. The locations of nodes in the network view are added in the form of a trailing comment line to the script, and therefore can be stored. If the script is read again, the configuration is recovered from the previous configuration.</li></ul>",
            "seeAlso": "IO / Edit,run - pauze,sensitivity analysis,genetics,Pareto"
        },
        "factorial": {
            "fName": "factorial",
            "nArgs": 1,
            "cat": "statistics",
            "help": "factorial(0)=1; factorial(1)=1; factorial(x)=nround(x)*factorial(x-1) for x>0.",
            "autoMapping": "Supports auto-mapping.",
            "example": "factorial(3)=6",
            "details": "Argument must be non-negative; value is rounded before calculation of factorial. The largest factorial supported is factorial(100).",
            "seeAlso": "bin,poisson",
            "external": "",
            "abbreviation": ""
        },
        "bin": {
            "fName": "bin",
            "nArgs": 2,
            "cat": "statistics",
            "help": "bin(n,m)=fac(n) / (fac(m)*fac(n-m)) = n(n-1)(n-2)(n-3).../((m(m-1)(m-2)(m-3) ...)((n-m)(n-m-1)(n-m-2)(n-m-3) ...)) for m and n >0 and n>=m, which is the number of ways m distinguishable items can be chosen from a set of n.",
            "autoMapping": "Supports auto-mapping.",
            "example": "bin(25,24)=25",
            "details": "Arguments must be non-negative; values are rounded before calculation of factorial. This expression is known as a <span class=\"accelEmph\">binomial coefficient</span>  or <amph>Newton's binomium</span>.",
            "seeAlso": "factorial,poisson",
            "external": "",
            "abbreviation": ""
        },
        "poisson": {
            "fName": "poisson",
            "nArgs": 3,
            "cat": "statistics",
            "help": "poisson(x,y,z)=(y ^ x) * exp(-y) / (x factorial) for both x and y >0. If z==false then it is the probability density; if z==true then it is the accumulative probability.",
            "autoMapping": "Supports auto-mapping.",
            "example": "bin(25,24)=25",
            "details": "Arguments must be non-negative; values is rounded before calculation of factorial. <br><br>Notice: the cumulative poisson distribution, for x>20 or x>20, is implemented by means of an approximate algorithm.",
            "seeAlso": "factorial,poisson",
            "external": "The approximated algorithm is taken from: <a href='http://www.questia.com/googleScholar.qst?docId=5000227714'>http://www.questia.com/googleScholar.qst?docId=5000227714</a>",
            "abbreviation": ""
        },
        "random": {
            "fName": "random",
            "nArgs": 0,
            "cat": "statistics",
            "help": "random()=random number between 0 and 1. ",
            "autoMapping": "Supports no auto-mapping, since the function takes no arguments.",
            "example": "if(random()>0.5,a,b) gives the result a and b each in 50% of the cases.",
            "details": "",
            "seeAlso": "",
            "external": "",
            "abbreviation": ""
        },
        "sin": {
            "fName": "sin",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "sin(x)=sine of angle x in radians.",
            "autoMapping": "Supports auto-mapping.",
            "example": "sin(0)=0<br>sin(PI/4)*sin(PI/4)=0.50",
            "details": "",
            "seeAlso": "cos,tan,asin,acos,atan,atan2",
            "external": "",
            "abbreviation": ""
        },
        "cos": {
            "fName": "cos",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "cos(x)=cosine of angle x in radians.",
            "autoMapping": "Supports auto-mapping.",
            "example": "cos(0)=1<br>cos(PI/4)*cos(PI/4)=0.50",
            "details": "",
            "seeAlso": "sin,tan,asin,acos,atan,atan2",
            "external": "",
            "abbreviation": ""
        },
        "tan": {
            "fName": "tan",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "tan(x)=tangent of angle x in radians.",
            "autoMapping": "Supports auto-mapping.",
            "example": "tan(0)=0<br>tan(x)=sin(x)/cos(x)",
            "details": "",
            "seeAlso": "sin,cos,asin,acos,atan,atan2",
            "external": "",
            "abbreviation": ""
        },
        "acos": {
            "fName": "acos",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "acos(x)=y means that x=cos(y).",
            "autoMapping": "Supports auto-mapping.",
            "example": "acos(1)=0<br>acos(x)=atan(sqrt(1-x*x)/x)<br>acos(vDot(a,b)/sqrt(vDot(a,a)*vDot(b,b)))=the angle between a and b",
            "details": "",
            "seeAlso": "sin,cos,asin,tan,asin,atan,atan2,vDot",
            "external": "See here <a href='http://en.wikipedia.org/wiki/Inverse_trigonometric_functions'>http://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a> for a host of useful trigonometric relations.",
            "abbreviation": ""
        },
        "asin": {
            "fName": "asin",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "asin(x)=y means that x=sin(y).",
            "autoMapping": "Supports auto-mapping.",
            "example": "asin(1)=PI/2<br>asin(0)=0",
            "details": "",
            "seeAlso": "sin,cos,acos,tan,asin,atan,atan2",
            "external": "See here <a href='http://en.wikipedia.org/wiki/Inverse_trigonometric_functions'>http://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a> for a host of useful trigonometric relations.",
            "abbreviation": ""
        },
        "atan": {
            "fName": "atan",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "tan(x)=sin(x)/cos(x)",
            "autoMapping": "Supports auto-mapping.",
            "example": "tan(0)=0",
            "details": "",
            "seeAlso": "sin,cos,asin,acos,atan,atan2",
            "external": "See here <a href='http://en.wikipedia.org/wiki/Inverse_trigonometric_functions'>http://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a> for a host of useful trigonometric relations.",
            "abbreviation": ""
        },
        "atan2": {
            "fName": "atan2",
            "nArgs": 2,
            "cat": "transcendental",
            "help": "atan2(x,y)=the angle of a line with horizontal extent x and vertical extent y, in radians. ",
            "autoMapping": "Supports auto-mapping.",
            "example": "atan2(1,1)/PI=0.25",
            "details": "",
            "seeAlso": "sin,cos,asin,acos,tan,atan",
            "external": "See here <a href='http://en.wikipedia.org/wiki/Inverse_trigonometric_functions'>http://en.wikipedia.org/wiki/Inverse_trigonometric_functions</a> for a host of useful trigonometric relations.",
            "abbreviation": ""
        },
        "exp": {
            "fName": "exp",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "exp(x)=exponential of x.",
            "autoMapping": "Supports auto-mapping.",
            "example": "exp(0)=1",
            "details": "",
            "seeAlso": "log,ln,pow",
            "external": "",
            "abbreviation": ""
        },
        "ln": {
            "fName": "ln",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "ln(x)=natural logarithm of x (base e).",
            "autoMapping": "Supports auto-mapping.",
            "example": "ln(exp(12))=12",
            "details": "Argument must be positive.",
            "seeAlso": "log,exp,pow",
            "external": "",
            "abbreviation": ""
        },
        "pow": {
            "fName": "pow",
            "nArgs": 2,
            "cat": "transcendental",
            "help": "pow(x,y)=x to the power y.",
            "autoMapping": "Supports auto-mapping.",
            "example": "log(pow(10,12))=12",
            "details": "First argument must be positive. With respect to unit- and dimension analysis, we adopt the position that non-integer exponentials are permitted, provided that the resulting exponentials on base units are integer. So, for p=9;kg2, pow(q,0.5)=3;kg",
            "seeAlso": "ln,exp,pow",
            "external": "",
            "abbreviation": ""
        },
        "log": {
            "fName": "log",
            "nArgs": 1,
            "cat": "transcendental",
            "help": "log(x)=Briggs logarithm of x.",
            "autoMapping": "Supports auto-mapping.",
            "example": "log(pow(10,12))=12",
            "details": "Argument must be positive.",
            "seeAlso": "ln,exp,pow",
            "external": "",
            "abbreviation": ""
        },
        "@": {
            "fName": "@",
            "nArgs": 2,
            "cat": "vector",
            "autoMapping": "only with respect to second argument. The returned result can be a scalar if the second argument is a scalar, but it will be a vector if the second argument is a vector.",
            "example": "@([1,2,[3,3,3],4,5],[1,[2,2]])=[2,[[3,3,3],[3,3,3]]]<br>@(@([3,[4,5]],1),1)=5<br>Also works with keys, for instance:<br>@(['x':12, 'y':'banana'],'y')='banana'.",
            "help": "@(x,y)=takes a vector as first argument; it returns the y'th element of x.NOTICE: this notation is deprecated. It is advised to use the dot-notation or the index notation: @(x,y) is the same as x[y] or, if y is a name, x.y.",
            "abbreviation": "+ACCELTM+ supports two abbreviations for @(x,y). First, if x is a term and y evaluates to a string expression, we can write x.y. For instance, x=(['a':3,'b':4]).b produces the value 4. (The parentheses are mandatory: ['a':3,'b':4].b is a syntax error, since ['a':3,'b':4] is not a term but a vector.). A second abbreviation, which works both for y being a string expression or a numeric expression, is x[y]. Both abbreviations make +ACCELTM+ scripts read similarly to script languages such as Javascript. Similar as to Javascript, for x a vector, x[4] is correct, whereas x.4 isn't.",
            "details": "Note 1: The second argument is base-0, so @([0,1,2,3],0)=0.<br> Note 2: In many computer language, the function application @(vector,index) is abbreviated by 'vector[index]'. In +ACCELTM+, the first argument of @( , ) often will be an expression rather than a vector-valued quantity. Indeed, thanks to auto-mapping, the following makes perfect sense: @(a+b,3) which returns the fourth(!) element of the vector that results from termwise adding the vectors a and b. In other programming languages, this should be something like (a+b)[3], which is not common - moreover, it would not make sense in languages that don't support auto-mapping. Therefore, the +ACCELTM+ script language has both a post-fix indexing operator of the form vector[index], a selection operator of the form '.property', and a selection function of the form @(x,y).",
            "external": "In the Mathematica(c) computer algebra system, <a href='http://www.wolfram.com/'>http://www.wolfram.com</a>, elements in lists are also uniformly indexed",
            "seeAlso": "vectors,scalars,auto-mapping"
        },
        "vMake": {
            "fName": "vMake",
            "nArgs": 2,
            "cat": "vector",
            "help": "vMake(x,y) creates a vector with y copies of x. Indices are 0, 1, 2, ..., y-1. If y &lt 0, an empty vector is returned.",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "No abbreviation.",
            "example": "vMake(3,5)=[3,3,3,3,3]<br>vMake('bla',3)=['bla','bla','bla']",
            "details": "Typically, vMake is +ACCELTM+'s simplest way to construct vectors.",
            "seeAlso": "vSpike,vGaussian,vSegment,vAggregate,iMake",
            "external": "In linear algebra, vectors are usually given in some frame. This frame is defnied by a basis. The basis consists of vectors. Ever wondered where these basis vectors come from?"
        },
        "vDom": {
            "fName": "vDom",
            "nArgs": 1,
            "cat": "vector",
            "help": "vDom(x) returns the domain of x.",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "No abbreviation.",
            "example": "vDom(['x':1,'y':2])=['x','y']<br>A typical use for the vDom function is in quantified expressions:<br>a=#(i,vDom(x),e,vAppend) maps the expression e (assumingly, e depends on i) over the index set of x. In this way, functions that do not support auto-mapping can be mapped over sets.",
            "details": "For a vector not indexed with keys, the function vDom returns the integers 0 ... length of the vector -1. For a vector with mixed indices, first the integer indices are returned.",
            "seeAlso": "quantified expression,vRange,vSeq,auto-mapping,vAppend",
            "external": "In some sense, the function vDom can be seen as the domain of a function - namely, if a vector is interpreted as a function from the index set to the indexed values."
        },
        "vRange": {
            "fName": "vRange",
            "nArgs": 1,
            "cat": "vector",
            "help": "vRange(x) returns the range of x.",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "No abbreviation.",
            "example": "vRange(['x':1,'y':2])=[1,2]<br>The range function ignores the index set, and ignores the order of the elements of the argument.",
            "details": "For a vector not indexed with keys, the function vRange simply returns the argument vector. For a vector with mixed indices, the order of the returned elements is not defined. <br><br>Notice: not to be confused with vSeq.",
            "seeAlso": "quantified expression,vDom,vSeq,vAppend",
            "external": "In some sense, the function vRange can be seen as the range of a function - namely, if a vector is interpreted as a function from the index set to the indexed values."
        },
        "vSeq": {
            "fName": "vSeq",
            "nArgs": 2,
            "cat": "vector",
            "help": "vSeq(x,y) returns a vector with the sequence of integers [x,x+1,x+2,...y-1].",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "In mathematics, this is usually abbreviated by x ,..., y-1.",
            "example": "vSeq(0,5)=[0,1,2,3,4]",
            "details": "Often used in combination with quantified expressions: #(i,vSeq(a,b),e,vAppend) maps the expression e over the set {a,a+1,a+2,...,b-1}. In this way, functions that do not support auto-mapping can be mapped over sets (vectors)",
            "seeAlso": "quantified expression,vDom,vRange,auto-mapping,vAppend",
            "external": ""
        },
        "vSequence": {
            "fName": "vSequence",
            "nArgs": 2,
            "cat": "vector",
            "help": "vSequence(x,y) is the same as vSeq(x,y).",
            "autoMapping": "Does not support auto-mapping.",
            "abbreviation": "In mathematics, this is usually abbreviated by x ,..., y-1.",
            "example": "vSequence(0,5)=[0,1,2,3,4]",
            "details": "Provided for backward compatibility with earlier versions of ACCEL; novel scripts should use vSeq instead of vSequence",
            "seeAlso": "quantified expression,vDom,vRange,auto-mapping,vAppend",
            "external": ""
        },
        "vConcat": {
            "fName": "vConcat",
            "nArgs": 2,
            "cat": "vector",
            "help": "vConcat(x,y) returns a the vector x with and y concatenated. Assumes that both arguments, when vectors, are indexed by integers. Any elements indexed by non-integer keys are treated as if indexed by integers.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vConcat([1,2,3,4],5)=[1,2,3,4,5]",
            "details": "vConcat is similar to vAppend, except that it is more liberal in the types of its arguments.<br><br>vExtend behaves similar to vConcat. In case all elements are indexed by integers, they are the same, but vConcat is faster. In case there are elements, indexed by non-integers, vConcat should not be used.",
            "seeAlso": "vAppend",
            "external": ""
        },
        "vAppend": {
            "fName": "vAppend",
            "nArgs": 2,
            "cat": "vector",
            "help": "vAppend(x,y) returns a the vector x with y appended. If x is a scalar, [x,y] is returned. If y is an empty vector, an empty vector is inserted as last element of x.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vAppend([1,2,3,4],5)=[1,2,3,4,5]",
            "details": "Often used in combination with quantified expressions: #(i,vSeq(a,b),e,vAppend) maps the expression e over the set {a,a+1,a+2,...,b-1}. In this way, functions that do not support auto-mapping can be mapped over sets (vectors). <br><br>Notice the difference between vAppend and vExtend:<br><br>vAppend([1,2,3,4],[5,6])=[1,2,3,4,[5,6]], whereas<br><br>vExtend([1,2,3,4],[5,6])=[1,2,3,4,5,6].<br><br>As a consequence, nesting quantified expressions with the vAppend operator produces an array with a dimension equal to the number of nestings; using the vExtend operator produces a one-dimensional array only. So<br><br>#(i,vSeq(0,3),#(j,vSeq(0,3),i*10+j,vExtend),vExtend)=[0,1,2,10,11,12,20,21,22]<br><br>and<br><br>#(i,vSeq(0,3),#(j,vSeq(0,3),i*10+j,vAppend),vAppend)=[[0,1,2],[10,11,12],[20,21,22]]",
            "seeAlso": "quantified expression,vExtend,vDom,vRange,auto-mapping",
            "external": ""
        },
        "vExtend": {
            "fName": "vExtend",
            "nArgs": 2,
            "cat": "vector",
            "help": "vExtend(x,y) if x is a vector, it returns a the vector x, extended with y or the elements of y if y is a vector. If x is not a vector, it creates a vector where x is the first element, and next as above. ",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vExtend([1,2,3,4],[5,6])=[1,2,3,4,5,6],<br>vExtend([x:3,y:5],[t:6])=[x:3,y:5,t:6]",
            "details": "Often used to add named elements to a vector. Notice the difference between vAppend and vExtend:<br><br>vAppend([1,2,3,4],[5,6])=[1,2,3,4,[5,6]], whereas<br><br>vExtend([1,2,3,4],[5,6])=[1,2,3,4,5,6].<br><br>As a consequence, nesting quantified expressions with the vAppend operator produces an array with a dimension equal to the number of nestings; using the vExtend operator produces a one-dimensional array only. So<br><br>#(i,vSeq(0,3),#(j,vSeq(0,3),i*10+j,vExtend),vExtend)=[0,1,2,10,11,12,20,21,22]<br><br>and<br><br>#(i,vSeq(0,3),#(j,vSeq(0,3),i*10+j,vAppend),vAppend)=[[0,1,2],[10,11,12],[20,21,22]]<br><br>vExtend behaves similar to vConcat. In case all elements are indexed by integers, they are the same, but vConcat is faster. In case there are elements, indexed by non-integers, vConcat should not be used.",
            "seeAlso": "quantified expression,vAppend,vConcat,vDom,vRange,auto-mapping",
            "external": ""
        },
        "vGaussian": {
            "fName": "vGaussian",
            "nArgs": 2,
            "cat": "vector",
            "help": "vGaussian(n,s) creates a vector of n scalar elements; indices are 0,1,2,...,n-1. Element i has value P*exp(-(i-n/2)*(i-n/2)/(2*s*s)), where i ranges from 0 to n-1, and where P is such that the sum over all elements is one.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "Notice 1:The second argument plays the role of sigma in the standard definition of the Gaussian. The Gaussian has an infinite support; parameter n necessarily is finite. Therefore, the resulting Gaussian will always be a truncated version, even if the ratio between n and s is very large. The normalisation nevertheless ensures that the (truncated) Gaussian can serve e.g. as a stable low pass filter.<br>Notice 2:For even n, the resulting approximation has no single extreme apex. For odd n, there is a single extreme apex.",
            "seeAlso": "vConvolve",
            "external": "See <a href='http://en.wikipedia.org/wiki/Gaussian_function'>http://en.wikipedia.org/wiki/Gaussian_function</a>",
            "abbreviation": "No abbreviation",
            "example": "vGaussian(6,3)=[0.14,0.17,0.19,0.19,0.17,0.14]<br>vGaussian(8,3)=[0.048,0.074,0.10,0.13,0.14,0.14,0.13,0.10,0.074,0.048]"
        },
        "vSpike": {
            "fName": "vSpike",
            "nArgs": 2,
            "cat": "vector",
            "help": "vSpike(x,y) creates a vector with y elements. Indices are 0,1,2,...y-1. The elements are all zero, except the element at location x, assuming x &lt y, which is set to 1.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vSpike(0,5)=[1,0,0,0,0]",
            "seeAlso": "vMake,vConvolve,vGaussian",
            "abbreviation": "No abbreviation",
            "details": "Often, a smooth 'bump' is required, e.g. to model some perturbation. A simple way to achieve this is to use a convolution of a spike with a Guassian: the location of the spike determines the centre position of the bump, and the Gaussian determined its width. For instance: bump=amplitude*vConvolve(vSpike(n*random(),n),vGaussian(gWidth,gSharp),5,0)",
            "external": "There is a conceptual similarity between a spike and a Dirac delta function: <a href='http://en.wikipedia.org/wiki/Dirac_delta_function'>http://en.wikipedia.org/wiki/Dirac_delta_function</a>."
        },
        "vConvolve": {
            "fName": "vConvolve",
            "nArgs": 4,
            "cat": "vector",
            "autoMapping": "Does not support auto-mapping.",
            "help": "vConvolve(x,y,n,m) calculates the convolution of x with y, shifted over n. That is: return[i]:=sum over j of x[i-n+j]*y[j]. The return vector has the same length as x. If m==0 the convolution is cyclic, if m==1 the convolution is zero-padded, that is: it is pretended that the vector x is extended with zeroes on both ends. If m==2 the convolution is padded with the first and last elements of x,that is: it is pretended that the vector x is extended with all the same elements on both ends.",
            "abbreviation": "No abbreviation.",
            "details": "The convolution can be used to implement e.g. a differentiation operator. Let v be a vector, then vConvolve(v,kernel,shift,0) is a discrete approximation of the derivative of v with respect to its index. The kernel could e.g. look like [-1,0,1] and the shift then should be 1 (indeed, the central value for the kernel is assumed for index 1). This kernel is rather sensitive for small details. A kernel such as [-0.2,-0.5,0,0.5,0.2] with shift 3 is less sensitive for small details and therefore gives a smoother result.<br><br>Notice: convolve applies addition to indices. Therefore indices must be integers; non-integer indices are ignored.",
            "example": "xArr=2*xArr{1}-(xArr{2}+vConvolve(xArr{1},kernel,4,0)), with kernel=[-0.0,-0.3,0,0,0.8,0,0,-0.3,-0.0]/200 implements a very simple solver for a 1-dimensional wave equation with an approximation for a second time derivative and a second 'spatial' derivative.",
            "seeAlso": "vSpike,vGaussian",
            "external": "See <a href='http://en.wikipedia.org/wiki/Convolution'>http://en.wikipedia.org/wiki/Convolution</a>"
        },
        "vLen": {
            "fName": "vLen",
            "nArgs": 1,
            "cat": "vector",
            "help": "vLen(x) returns the length of vector x.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vLen([0,0,0])=3<br>vLen([])=0",
            "details": "Notice 1: For a vector where elements are themselves are vectors, only the 'top level' length is given. So vLen([1,[2,3],4])=3, not 4.<br>Notice 2: For a vector with elements that are given as key-value pairs, such as v=[3,4,5,'x':6,'y':7,'z':8], only the elements with regular (=integer) indices contribute to the length. So in this case, the length will be 3, not 6.<br><br>Notice: if the argument is a scalar instead of a vector, length=0 is returned.",
            "seeAlso": "vSegment,vAggregate",
            "external": "Our convention for the length of a vector with mixed integer indices and key-indices is conform javascript (see for instance <a href='http://www.w3schools.com/jsref/jsref_obj_vector.asp'>http://www.w3schools.com/jsref/jsref_obj_vector.asp</a>)",
            "abbreviation": "No abbreviation"
        },
        "vNormAbs": {
            "fName": "vNormAbs",
            "nArgs": 1,
            "cat": "vector",
            "help": "vNormAbs(x) returns the the sum of the absolute values of the elements of vector x.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "For vectors with non-scalar elements, the contributions of non-scalar elements are taken to 0.",
            "seeAlso": "vNormEuclid,vNormFlat",
            "external": "There are numerous norms for vectors (and other data) that all have meaningfull applications. See for instance <a href='http://en.wikipedia.org/wiki/Norm_(mathematics)'>http://en.wikipedia.org/wiki/Norm_(mathematics)</a>.",
            "example": "vNormAbs([1,-1,1,-1,1,-1])=6",
            "abbreviation": "In mathematics, vector norms are usually written as a form of bracketing, such as |a| or ||a||. Such abbreviations are not supported in +ACCELTM+."
        },
        "vNormFlat": {
            "fName": "vNormFlat",
            "nArgs": 1,
            "cat": "vector",
            "help": "vNormFlat(x) returns the the sum of the values of the elements of vector x.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "For vectors with non-scalar elements, the contributions of non-scalar elements are taken to 0. If the elements of x are strings instead of numbers, these are concatenated: vNormFlat(['a','b','c'])='abc'. If elements of x are indexed by keys instead of integer indices, the integer values are summed or concatenated first, the non-integer indexed values come next. For numeric values, this has no implications; for strings, however, the addition (=concatenation) is order-dependent.<br><br>Notice: if the argument is scalar instead of vector, the argument is returned.",
            "seeAlso": "vNormEuclid,vNormAbs,add,vNormSq",
            "external": "There are numerous norms for vectors (and other data) that all have meaningfull applications. See for instance <a href='http://en.wikipedia.org/wiki/Norm_(mathematics)'>http://en.wikipedia.org/wiki/Norm_(mathematics)</a>.",
            "example": "vNormAbs([1,-1,1,-1,1,-1])=0",
            "abbreviation": "In mathematics, vector norms are usually written as a form of bracketing, such as |a| or ||a||. Such abbreviations are not supported in +ACCELTM+."
        },
        "vNormEuclid": {
            "fName": "vNormEuclid",
            "nArgs": 1,
            "cat": "vector",
            "help": "vNormEuclid(x) returns the the square root of the sum of the squares of the values of the elements of vector x.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "For vectors with non-scalar elements, the contributions of non-scalar elements are taken to 0. <br><br>Notice: if the argument is scalar instead of vector, the argument is returned.",
            "seeAlso": "vNormFlat,vNormAbs,vNormalize,vNormSq",
            "external": "There are numerous norms for vectors (and other data) that all have meaningfull applications. See for instance <a href='http://en.wikipedia.org/wiki/Norm_(mathematics)'>http://en.wikipedia.org/wiki/Norm_(mathematics)</a>.",
            "example": "vNormEuclid([2,2,2])=2 sqrt(3)",
            "abbreviation": "In mathematics, vector norms are usually written as a form of bracketing, such as |a| or ||a||. Such abbreviations are not supported in +ACCELTM+."
        },
        "vNormSq": {
            "fName": "vNormSq",
            "nArgs": 1,
            "cat": "vector",
            "help": "vNormSq(x) returns the the sum of the squares of the values of the elements of vector x.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "For vectors with non-scalar elements, the contributions of non-scalar elements are taken to 0. <br><br>Notice: if the argument is scalar instead of vector, the argument squared  is returned.",
            "seeAlso": "vNormFlat,vNormAbs,vNormalize,vNormEuclid",
            "external": "There are numerous norms for vectors (and other data) that all have meaningfull applications. See for instance <a href='http://en.wikipedia.org/wiki/Norm_(mathematics)'>http://en.wikipedia.org/wiki/Norm_(mathematics)</a>.",
            "example": "vNormAbs([1,-1,1,-1,1,-1])=0",
            "abbreviation": "In mathematics, vector norms are usually written as a form of bracketing, such as |a| or ||a||. Such abbreviations are not supported in +ACCELTM+."
        },
        "vNormalize": {
            "fName": "vNormalize",
            "nArgs": 1,
            "cat": "vector",
            "help": "vNormalize(x) returns a normalized version of vector x, using the Euclidean (square-root-of-squares) norm.",
            "autoMapping": "Does not support auto-mapping.",
            "details": "Notice 1: Non-scala elements of x are not taken into account in calculating the norm, and these elements are returned unaltered.<br>Notice 2: The null-vector cannot be normalized; we return a null vector instead. <br>Notice 3: If a scalar intead of a vector is given, the scalar value 1 is returned.",
            "seeAlso": "vNormEuclid",
            "example": "vNormalize([1,1,1])=value=[0.58,0.58,0.58]",
            "external": "Normalized vectors play a crucial role in many areas of linear algebra. See for instance <a href='http://en.wikipedia.org/wiki/Normalized_vector'>http://en.wikipedia.org/wiki/Normalized_vector</a>",
            "abbreviation": "In mathematics, one usually writes x/|x| for a normalized version of vector x. In +ACCELTM+, normalization cannot be abbreviated."
        },
        "vSegment": {
            "fName": "vSegment",
            "nArgs": 3,
            "cat": "vector",
            "help": "vSegment(x,start,stop) returns the segment of x, starting at location 'start' with length stop-start.",
            "autoMapping": "Does not support auto-Mapping",
            "example": "vSegment([1,2,3,4,5],1,2)=[2] (and not 2)<br>vSegment([1,[2,3,4,5],3,4,5],1,2)=[[2,3,4,5]]",
            "details": "If stop and start are equal, the empty vector is returned; similar if start exceeds stop. If the input vector is too short to produce a segment of the length asked for, the result is padded with zeroes.<br><br>Notice: vSegment assumes the indices of the vector to be integers. Elements with non-integer indices in x are ignored.",
            "seeAlso": "vAggregate,vLen",
            "abbreviation": "No abbreviation"
        },
        "vAggregate": {
            "fName": "vAggregate",
            "nArgs": 3,
            "cat": "vector",
            "help": "vAggregate(x,y,n) creates a vector which consists of the first n elements of x; next all elements of y, and finally the remainder of x. ",
            "autoMapping": "Does not support auto-Mapping",
            "example": "vAggregate([1,2,3,4],[10,[20,21,22]],1)=[1,10,[20,21,22],2,3,4]",
            "details": "If y is a scalar, it is interpreted as a 1-element vector. If n is larger than the length of x, the vector y is concatenated at the end of x. If vector x is a scalar, an error is generated.<br><br>Notice: vAggregate assumes the indices of the vector to be integers. Elements with non-integer indices in x or y are ignored.",
            "seeAlso": "vSegment,vLen",
            "abbreviation": "No abbreviation",
            "external": "vAggregate can be used to implement a vector concatenation, as in javascript. See  <a href='http://www.w3schools.com/jsref/jsref_concat_vector.asp'>http://www.w3schools.com/jsref/jsref_concat_vector.asp</a> "
        },
        "vDot": {
            "fName": "vDot",
            "nArgs": 2,
            "cat": "vector",
            "help": "vDot(x,y) can be used to calculate the standard inproduct of vectors x and y, that is, the sum of the products of terms with corresponding indices. Only contributions of scalar terms are summed. ",
            "details": "If both x and y are scalars, the product of x and y is returned. If one argument is scalar and the other is vector, the scalar argument is interpreted as a vector of all the same values. If both arguments are vectors, the indices of x are used to iterate. Only elements from y are taken with indices that occur in the index set of x. Indices may be integers and/or non-integer keys.<br><br>Notice: Unlike vMatMatMul, vDot ignores the difference between rows and columns.",
            "autoMapping": "Does not support auto-mapping",
            "seeAlso": "vMatVecMul,vNormalize",
            "example": "vDot([1,0,0],[0,1,0])=0. Also vDot(['x':1,'y':1],['x':2,'y':2,'z':3])=4. The angle between two vectors can be computed as acos(vDot(a,b)/sqrt(vDot(a,a)*vDot(b,b))).",
            "external": "The dot product is extensively used in many areas in mathematics. See for instance <a href='http://en.wikipedia.org/wiki/Dot_product'>http://en.wikipedia.org/wiki/Dot_product</a>",
            "abbreviation": "In mathematics, dot products (a.k.a. inner product or scalar product) are sometimes abbreviated as &lt a,b &gt or (a,b). +ACCELTM+ has no abbreviation for the dot product. "
        },
        "vTranspose": {
            "fName": "vTranspose",
            "nArgs": 1,
            "cat": "vector",
            "help": "vTranspose(x) produces the transposed matrix x. ",
            "details": "It is assumed that x is a vector of vectors. In case all vectors have the same set of indices (in the case of integer indices: have all equal length - in other words, x is a rectangular matrix), the resulting matrix is also rectangular. In case of different sets of indices, the resulting matrix will be fully left-adjusted: there are no undefined elements, and missing elements are not substituted by zeroes. In case of a non-rectangular matrix, therefore, the transpose of the transpose is not necessary equal to the original matrix. Elements that are not scalar are cloned. <br><br>Notice: indices can both be integers or non-integer keys. This is particularly useful e.g. in models where several points in space need to be taken into account. One point is a vector with keys as 'x', 'y', et cetera; the points themselves are indexed with integers. For plotting we need the coordinates 'x', 'y' as outermost index; for vector calculations we need the point number as outermostr index. The transpose operation gives exactly the right conversion. See the last example.<br><br>In case the argument is a vector or a scalar instead of a matrix, the argument proper is returned.",
            "autoMapping": "Does not support auto-mapping.",
            "seeAlso": "vMatInverse",
            "example": "vTranspose([[1,10,100],[2,20,200],[3,30,300]])=[[1,2,3],[10,20,30],[100,200,300]]<br>vTranspose([[1,10,100],[2,20,200,2000],[3,30,300]])=[[1,2,3],[10,20,30],[100,200,300],[2000]]<br>vTranspose(vTranspose([[1,10,100],[2,20,200,2000],[3,30,300]]))=[[1,10,100,2000],[2,20,200],[3,30,300]]<br>vTranspose([['x':1,'y':2],['x':10,'y':20])=['x':[1,10],'y':[2,20]]",
            "abbreviation": "In mathematics, a transpose is sometimes indicated by a star or a superscript T. No abbreviations in +ACCELTM+."
        },
        "vMatMatMul": {
            "fName": "vMatMatMul",
            "nArgs": 2,
            "cat": "vector",
            "help": "vMatMatMul(x,y) multiplies matrix x with matrix y. Both x and y can also be vectors instead of matrices, or scalars instead of vectors, and all combinations.",
            "details": "In all cases, the type of the returned object is appropriate. There is no distinction between column and row vectors; in case the difference need to be made explicit, write [[1,2,3]] for a row vector, i.e. a matrix with a single row, or [[1],[2],[3]] for a column vector, that is: a matrix with rows with length 1.<ul></ul><li>matrix X matrix = matrix</li><li>vector X matrix = vector (vector interpreted as a row, but not returned as a 1 X n matrix)</li><li>scalar X matrix = matrix</li><li>matrix X vector = vector (vector interpreted as a column, but nor returned as an n X 1 matrix)</li><li>vector X vector = a scalar, that is: the dot product. In case the direct product should be computed, explicitly give both arguments as matrix, x having one column and y having one row. So vMatMatMul([[1],[2]],[[10,20]])=[[10,20],[20,40]] whereas vMatMatMul([[10,20]],[[1],[2]])=[[50]]</li><li>scalar X vector=vector</li><li>matrix X scalar = matrix</li><li>vector X scalar=vector</li><li>scalar X scalar=scalar.",
            "example": "Rotations and other linear transformations are implemented using vector-matrix products. For instance: <br>angle=PI/4<br>cs=cos(angle)<br>sn=sin(angle)<br>m=[[cs,sn],[-sn,cs]]<br>loc=if(reset,[30,0],vMatVecMul(m,loc{1}))",
            "abbreviation": "No abbreviation",
            "autoMapping": "Does not support auto-mapping.",
            "seeAlso": "vMatMatMul,vMatSolve"
        },
        "vMatInverse": {
            "fName": "vMatInverse",
            "nArgs": 1,
            "cat": "vector",
            "help": "vMatInverse(x) calculates the inverse of the matrix x, viewed as a vector where the elements are rows. ",
            "autoMapping": "Does not support auto-mapping.",
            "example": "vMatInverse(vMatInverse([[3,4,5],[23,56,67],[1,8,7]]))=[[3.0,4.0,5.0],[23,56,67],[1.0,8,7]]",
            "details": "If x is not square, an error is generated. If the argument is a scalar, the inverse of the scalar (1/x) is returned. ",
            "seeAlso": "vMatTranspose,vMatSolve,vEigenSystem",
            "external": "The +ACCELTM+Accel linear algebra library is based on the work of Peter Coxhead, <a href=http://www.cs.bham.ac.uk/~pxc/''>http://www.cs.bham.ac.uk/~pxc/</a>",
            "abbreviation": "In mathematics, inverse is often indicated by superscript '-1'. In +ACCELTM+, there is no abbreviation for taking the inverse of a matrix."
        },
        "vEigenSystem": {
            "fName": "vEigenSystem",
            "nArgs": 1,
            "cat": "vector",
            "help": "vEigenSystem(x) calculates the eigensystem of matrix x. The eigensystem is a 3-component vector. The first component is a vector with real parts of the eigenvalues; the second component is a vector with imaginary parts of the eigenvalues; the third component is a vector where every component is an eigenvector. ",
            "autoMapping": "Does not support auto-mapping.",
            "example": "This script is instructive to explore the relation between rotation matrices and (complex) eigenvalues:<br><br>m=[[1,0,0],[0,c,s],[0,-s,c]]<br>c=cos(alpha)<br>s=sin(alpha)<br>alpha=PI*slider(10,0,100)/100<br>b=vEigenSystem(m)<br>realE=@(b,0) <br>imgE=@(b,1) <br>eigVector=@(b,2)",
            "details": "x needs to be a square matrix, otherwise an error is generated.",
            "seeAlso": "vMatSolve,vMatInverse,vMatTranspose",
            "external": "The +ACCELTM+ linear algebra library is based on the work of Peter Coxhead, <a href=http://www.cs.bham.ac.uk/~pxc/''>http://www.cs.bham.ac.uk/~pxc/</a>",
            "abbreviation": ""
        },
        "vMatSolve": {
            "fName": "vMatSolve",
            "nArgs": 2,
            "cat": "vector",
            "help": "vMatSolve(m,v) calculates the solution of the linear set of equations in unknown vector x mx=v.",
            "autoMapping": "Does not support auto-mapping.",
            "example": "m=[[1,0,0.01],[1,0,0],[0,1,0]]<br>a=vMatVecMul(m,vMatSolve(m,[7,8,9]))<br>produces for a=[7,8,9].",
            "details": "Matrix must have rows with the length of vector v. The number of rows must be at least the number of columns. A non-square system is solved in least-squares sense. All elements of m and v must be scalars. ",
            "seeAlso": "vMatInverse,vMatTranspose",
            "external": "The +ACCELTM+ linear algebra library is based on the work of Peter Coxhead, <a href=http://www.cs.bham.ac.uk/~pxc/''>http://www.cs.bham.ac.uk/~pxc/</a>",
            "abbreviation": "No abbreviation."
        },
        "vVecRamp": {
            "fName": "vVecRamp",
            "nArgs": 3,
            "cat": "vector",
            "help": "vVecRamp(x,y,s)=the result of interpolating the values in the y-vector corresponding to the indeces in the v-vector enclosing s. In other words, x is a vector of abcissae, y is a vector of ordinates; search the pair of subsequent abcissae enclosing s, and do a linear interpolation on the y-s on that interval. In case s is less than x[0], return y[0]; in case it is larger than x[vLen(x)-1], return y[vLen(y)-1].",
            "autoMapping": "Auto-mapping not supported.",
            "example": "vVecRamp([10,20,30,40],[0,s1,s2,0],time): so s between 20 and 30, interpolate s1 and s2. vVecRamp is a simple means to fully specify a (piecewise linearly approximated) curve in +ACCELTM+. Applications could include to produce a programmed time-behaviour.",
            "details": "Notice 1: The elements in x should preferably be sorted. If no, vVecRamp will sort them (and the y-values accordingly), but this reduces the efficiency.<br>Notice 2: If vectors x and y are of different length, the shorter of the two defines the range of abcissa-ordinate points ",
            "seeAlso": "ramp",
            "external": "vVecRamp does a piecewise linear interpolation. This is the simplest of all interpolation schemes. For more material on interpolation and approximation of discrete data by a continuous function, see <a href='http://nl.wikipedia.org/wiki/Spline'>http://nl.wikipedia.org/wiki/Spline</a>",
            "abbreviation": "No abbreviation."
        },
        "vector": {
            "fName": "vector",
            "cat": "vector",
            "help": "+ACCELTM+'s approach to grouping data. A quantity is either scalar or vector. Vector quantities are denoted by square brackets: [1,2,3]  is a vector of three scalars.",
            "autoMapping": "The behavior of many operators depends on whether the arguments are scalars or vectors. For instance, in 3+5, the '+' operator takes two scalar arguments, and produces the scalar result '8'. In [1,1]+[5,6], arguments are vectors, and the result is the vector [6,7]. ",
            "example": "[[1],[2],[3]] and [[1,2,3]] are two different vectors. The first one is a vector with three elements, each a one-element vector; the second is a vector with one element, being a three-element vector. Sometimes the first is called a column, the second a row representation.",
            "details": "Vectors realise the intuition of <span class=\"accelEmph\">grouping</span> or <span class=\"accelEmph\">bundling</span> the atributes in an object. Grouping has three aspects: <span class=\"accelEmph\">nominal indexing</span>, <span class=\"accelEmph\">ordinal indexing</span>, and <span class=\"accelEmph\">hierarchy</span>. All three aspects are found in +ACCELTM+ vectors. <ul><li>Nominal indexing makes use of keys: ['x':4,'y':5] is an object with two attributes, one called 'x' (having value 4), the other one called 'y' (having value 5). The names 'x' and 'y' in this example are the so-called <span class=\"accelEmph\">keys</span>.</li><li>Ordinal indexing makes use of the ordering of items. For instance, in the vector ['1':'red', '2':'green','3':'blue'], the names of the keys suggest an ordering. It seems a bit superfluous to explicitly include these keys: why not simply write v=['red','green','blue'], and have the ordering implied by the absence of explicit keys. In this case we can simply say 'the second element of v is 'green'', or @(v,1)='green'.</li><li>Elements of vectors can be vectors themselves. This introduces hierarchy: [['name':'John','instrument':'guitar'],['name':'Paul','instrument':'bass'],['name':'George','instrument':'drums'],['name':'George','instrument':'guitar']] represents an entity (object) we could call 'Beatles'.</li></ul>All +ACCELTM+ vectors can hold mixtures of nominally indexed, ordinally indexed, and hierarchical values. This does not mean that it is recommended to strive for complexity: it is often adviseable to give names to substructures. In the Beatles 'example': why not set beatles=[beatleJohn,beatlePaul,beatlyGeorge,beatleRingo], where beatleJohn=['name': 'John','instrument'guitar'], et cetera. (notice that names without quotes are quantities!) ",
            "seeAlso": "auto-mapping,scalar,data type,hierarchy,indexing,nominal,ordinal",
            "external": "Vectors is one approach to data modelling. For reading could start here: <a href='http://en.wikipedia.org/wiki/Data_modeling'>http://en.wikipedia.org/wiki/Data_modeling</a>",
            "abbreviation": "Every quantity in +ACCELTM+ can be either scalar or vector, so once we define p=[3,4,5] and q=[10,20,30]  we can simply write their sum as p+q; auto-mapping will cause the result to be [13,24,35]."
        },
        "scalar": {
            "fName": "scalar",
            "cat": "vector",
            "help": "Scalar quantities realize the intuition of 'atomic' information: information that has no internal structure. ",
            "autoMapping": "Automapping allows a free mix between scalar and vector quantities in one expression, such as '3+{10,20,30]=[13,23,33]",
            "example": "Mixing types. although sometimes useful, can be a bit puzzling: a='john'+7 is allowed and produces the value 'john7'. ",
            "details": "+ACCELTM+ builds the interpration of scalar data on the javascript conventions. In fact, internally scalars are javascript scalars. This means that depending on the contents, the type of scalar is determined. a='John' means that a will hold a string, and b=6+8 means that b will hold a number. The third supported type is Boolean: for instance, c=(4 &lt 5) will cause c to hold the Boolean value true. ",
            "seeAlso": "vector,auto-mapping",
            "external": "<a href='http://jibbering.com/faq/notes/type-conversion/'>http://jibbering.com/faq/notes/type-conversion/</a> contains a discussion about types and the conversion between them."
        },
        "exception handling and special cases with vectors": {
            "fName": "exception handling and special cases with vectors",
            "cat": "vector",
            "help": "Vectors and scalars should not be confused. There is a difference between [[1,2,3]] and [[1],[2],[3]], and also between [[1]] and [1]; further, [] is not 0 et cetera. ",
            "autoMapping": "",
            "example": "The function vMatRamp(x,y,x0) expects two vectors of equal length, x and y. The x are the abcissae and the y are the ordinates of a series of points that we want to interpolate. In case x and y are of different length, this formally should give an error; in stead +ACCELTM+ works with the shortest of the two lengths and tacitly ignores the trailing elements of the longer vector.",
            "details": "There can be reasons, however, when the type checking should be used with some tolerance. First, there are cases where little harm can result. For instance, vMatInverse([[2]])=[[0.5]] (indeed, the inverse of a one-by-one matrix), and technically speaking, vMatInverse(2) would be meaningless. In such cases, however, +ACCELTM+ tries to come up with reasonable and non-trivual results. Here the scalar 0.5 is returned. This reduces the number of runtime exceptions. Second, there are situations where an +ACCELTM+ model depends on time, and initially the types are not known yet. Think of a vector x that is transformed as in x=if(time<1,[5,5,5],1.001*x{1}). The expression x{1} is the contents of x at the previous time point, but when the simulation starts there is no previous time point. In that case, x{1} returns 'null',  which is no vector. In this case, this is harmless since the multiplication is both defined (thanks to auto-mapping) for scalars and for vectors. Moreover, the result 1.001*x{1} is not going to be used when time<1. But if the processing would take place via, say, a matrix function, requiring a vector as argument, this would produce a formal problem. To deal with such such exceptions, a tolerant policy is used throughout, giving (as much as possible) intuitive behaviour.",
            "seeAlso": "auto-mapping,vMatRamp,vMatInverse"
        }
    }
}
