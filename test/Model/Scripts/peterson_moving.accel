dt=slider(0.1,0.01,1)
// just for fun, we take the Peterson graph from the demo-script 'peterson.txt', 
// and make the values of all properties a smooth function of time.
// We use a single generator function to do so: the function gen(low,high)
// which produces a sin-function of time oscillating between low and high.
// The frequency is random: each quantioty has its own frequency. To this aim,
// we fill a vector rnd[] with 70 random values opn initialization.
//
// Notice that the size of time increments is given by quantity dt, which is under slider control.
d=plot([edges,nodes])
    //  
eStr=[plotType:'vector',type:'segment',x1:[mode:'data',ref:1],x2:[mode:'data',ref:2],y1:[mode:'data',ref:3],y2:[mode:'data',ref:4],width:[mode:'data',ref:5],col_r:[mode:'data',ref:6],col_g:[mode:'data',ref:7],col_b:[mode:'data',ref:8],tag:[mode:'data',ref:9]]
    //  
nStr=[plotType:'bubble',x:[mode:'data',ref:1],y:[mode:'data',ref:2],diameter:[mode:'data',ref:3],col_r:[mode:'data',ref:4],col_g:[mode:'data',ref:5],col_b:[mode:'data',ref:6],tag:[mode:'data',ref:7]]
    //  
e=[e1,e2,e3,e4,e5,e6,e7,e8,e9,e10]
    //  
e1=['e1':0,'e2':1,'w':gen(0,40,0),'r':gen(0,255,10),'g':gen(0,255,20),'b':gen(0,255,30),'t':'edge1']
    //  
e10=['e1':4,'e2':1,'w':gen(0,40,1),'r':gen(0,255,11),'g':gen(0,255,21),'b':gen(0,255,31),'t':'edge10']
    //  
e2=['e1':1,'e2':2,'w':gen(0,40,2),'r':gen(0,255,12),'g':gen(0,255,22),'b':gen(0,255,32),'t':'edge2']
    //  
e3=['e1':2,'e2':3,'w':gen(0,40,3),'r':gen(0,255,13),'g':gen(0,255,23),'b':gen(0,255,33),'t':'edge3']
    //  
e4=['e1':3,'e2':4,'w':gen(0,40,4),'r':gen(0,255,14),'g':gen(0,255,24),'b':gen(0,255,34),'t':'edge4']
    //  
e5=['e1':4,'e2':0,'w':gen(0,40,5),'r':gen(0,255,15),'g':gen(0,255,25),'b':gen(0,255,35),'t':'edge5']
    //  
e6=['e1':0,'e2':2,'w':gen(0,40,6),'r':gen(0,255,16),'g':gen(0,255,26),'b':gen(0,255,36),'t':'edge6']
    //  
e7=['e1':1,'e2':3,'w':gen(0,40,7),'r':gen(0,255,17),'g':gen(0,255,27),'b':gen(0,255,37),'t':'edge7']
    //  
e8=['e1':2,'e2':4,'w':gen(0,40,8),'r':gen(0,255,18),'g':gen(0,255,28),'b':gen(0,255,38),'t':'edge8']
    //  
e9=['e1':3,'e2':0,'w':gen(0,40,9),'r':gen(0,255,19),'g':gen(0,255,29),'b':gen(0,255,39),'t':'edge9']
    //  
eT=vTranspose(e)
    //  
edges=[eStr,xb,xe,yb,ye,eT.w,eT.r,eT.g,eT.b,eT.t]
    //  xb: x-coordinates of begin points
    //  xe: x-coordinates of end points
    //  yb: y-coordinates of begin points
    //  ye: y-coordinates of end points
    //  eT.w: width of edges
    //  eT.t: tags of edges
    //  eT.r,eT.g,eT.b: color of edges 
gen(lo,hi,freq)=(lo+hi+(hi-lo)*sin(t*dt*rnd[freq]))/2
    //  
n=[n1,n2,n3,n4,n5]
    //  
n1=['x':gen(0,100,65),'y':gen(0,100,40),'w':gen(0,40,45),'r':gen(0,255,50),'g':gen(0,255,55),'b':gen(0,255,60),'t':'node1']
    //  
n2=['x':gen(0,100,66),'y':gen(0,100,41),'w':gen(0,40,46),'r':gen(0,255,51),'g':gen(0,255,56),'b':gen(0,255,61),'t':'node2']
    //  
n3=['x':gen(0,100,67),'y':gen(0,100,42),'w':gen(0,40,47),'r':gen(0,255,52),'g':gen(0,255,57),'b':gen(0,255,62),'t':'node3']
    //  
n4=['x':gen(0,100,68),'y':gen(0,100,43),'w':gen(0,40,48),'r':gen(0,255,53),'g':gen(0,255,58),'b':gen(0,255,63),'t':'node4']
    //  
n5=['x':gen(0,100,69),'y':gen(0,100,44),'w':gen(0,40,49),'r':gen(0,255,54),'g':gen(0,255,59),'b':gen(0,255,64),'t':'node5']
    //  
nT=vTranspose(n)
    //  
nodes=[nStr,nT.x,nT.y,nT.w,nT.r,nT.g,nT.b,nT.t]
    //  nT.x: x-coordinates of nodes
    //  nT.y: x-coordinates of nodes
    //  nT.w: width (diameter) of nodes
    //  nT.r,nT.g,nT.b: color of nodes
    //  nT.t: tags of nodes 
rnd=if(t==1,#(i,vSequence(0,70),random(),vAppend),rnd{1})
    //  
t=t{1}+1
    //  
xb=#(i,vDom(e),n[e[i].e1].x,vAppend)
    //  
xe=#(i,vDom(e),n[e[i].e2].x,vAppend)
    //  
yb=#(i,vDom(e),n[e[i].e1].y,vAppend)
    //  
ye=#(i,vDom(e),n[e[i].e2].y,vAppend)
    // 